{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap 8c098980c443bfaf9ae9","webpack:///./src/index.js","webpack:///./src/helpers.js","webpack:///./~/immutable/dist/immutable.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_toConsumableArray","arr","Array","isArray","arr2","length","from","selectorPipe","selector","branchIf","pipe","undefined","_immutable","_helpers","arrayOfMutators","state","errorInFirstParam","isFirstParamArray","isImmutable","withMutations","reduceState","predicate","returnIfTrue","returnIfFalse","runIfTrue","runIfFalse","reducer","action","type","DEFAULT","globalMutators","arguments","Error","reduce","mutator","areAllFunctions","arrayOfFunctions","every","func","global","MakeRef","ref","SetRef","OwnerID","arrCopy","offset","len","Math","max","newArr","ii","ensureSize","iter","size","__iterate","returnTrue","wrapIndex","index","uint32Index","NaN","wholeSlice","begin","end","resolveBegin","resolveIndex","resolveEnd","defaultIndex","Infinity","min","maybeImmutable","isCollection","isRecord","__ownerID","maybeCollection","IS_ITERABLE_SENTINEL","isKeyed","maybeKeyed","IS_KEYED_SENTINEL","isIndexed","maybeIndexed","IS_INDEXED_SENTINEL","isAssociative","maybeAssociative","isOrdered","maybeOrdered","IS_ORDERED_SENTINEL","maybeRecord","IS_RECORD_SENTINEL","isValueObject","maybeValue","equals","hashCode","iteratorValue","k","v","iteratorResult","done","iteratorDone","hasIterator","maybeIterable","getIteratorFn","isIterator","maybeIterator","next","getIterator","iterable","iteratorFn","REAL_ITERATOR_SYMBOL","FAUX_ITERATOR_SYMBOL","isArrayLike","isSeq","maybeSeq","IS_SEQ_SENTINEL","emptySequence","EMPTY_SEQ","ArraySeq","keyedSeqFromValue","seq","IteratorSeq","CollectionSeq","fromEntrySeq","ObjectSeq","TypeError","indexedSeqFromValue","maybeIndexedSeqFromValue","seqFromValue","is","valueA","valueB","valueOf","fromJS","converter","fromJSWith","defaultConverter","","stack","key","keyPath","parentValue","toSeq","IndexedSeq","isPlainObj","KeyedSeq","indexOf","push","converted","map","slice","pop","toMap","toList","constructor","smi","i32","hash","h","STRING_HASH_CACHE_MIN_STRLEN","cachedHashString","hashString","hashJSObj","toString","string","stringHashCache","STRING_HASH_CACHE_SIZE","STRING_HASH_CACHE_MAX_SIZE","charCodeAt","obj","usingWeakMap","weakMap","UID_HASH_KEY","canDefineProperty","propertyIsEnumerable","getIENodeHash","objHashUID","set","isExtensible","writable","apply","nodeType","node","uniqueID","documentElement","flipFactory","collection","flipSequence","makeSequence","_iter","flip","reverse","reversedSequence","has","includes","cacheResult","cacheResultThrough","__iterateUncached","fn","this$1","__iteratorUncached","ITERATE_ENTRIES","iterator","__iterator","Iterator","step","ITERATE_VALUES","ITERATE_KEYS","mapFactory","mapper","context","mappedSequence","notSetValue","NOT_SET","entry","reverseFactory","useKeys","filterFactory","filterSequence","iterations","countByFactory","grouper","groups","Map","asMutable","update","a","asImmutable","groupByFactory","isKeyedIter","OrderedMap","coerce","collectionClass","reify","sliceFactory","originalSize","resolvedBegin","resolvedEnd","sliceSize","resolvedSize","sliceSeq","skipped","isSkipping","takeWhileFactory","takeSequence","iterating","skipWhileFactory","skipSequence","skipping","concatFactory","values","isKeyedCollection","iters","concat","KeyedCollection","filter","singleton","concatSeq","toKeyedSeq","toSetSeq","flatten","sum","flattenFactory","depth","flatSequence","flatDeep","currentDepth","stopped","flatMapFactory","interposeFactory","separator","interposedSequence","sortFactory","comparator","defaultComparator","entries","toArray","sort","b","forEach","SetSeq","maxFactory","maxCompare","comp","zipWithFactory","keyIter","zipper","zipSequence","iterators","Collection","isDone","steps","some","validateEntry","IndexedCollection","SetCollection","create","Seq","coerceKeyPath","invariant","condition","error","assertNotInfinite","quoteString","JSON","stringify","String","isMap","maybeMap","IS_MAP_SENTINEL","mapIteratorValue","mapIteratorFrame","prev","__prev","makeMap","ownerID","hash$$1","MapPrototype","_root","__hash","__altered","emptyMap","EMPTY_MAP","updateMap","newRoot","newSize","didChangeSize","CHANGE_LENGTH","didAlter","DID_ALTER","updateNode","ArrayMapNode","shift","keyHash","ValueNode","isLeafNode","HashCollisionNode","mergeIntoNode","newNode","idx1","MASK","idx2","nodes","SHIFT","BitmapIndexedNode","createNodes","packNodes","count","excluding","bitmap","packedII","packedNodes","bit","expandNodes","including","expandedNodes","SIZE","HashArrayMapNode","mergeIntoMapWith","merger","collections","mergeIntoCollectionWith","deepMerger","oldVal","newVal","mergeDeep","deepMergerWith","mergeDeepWith","nextValue","x","mergeIntoMap","updateInDeepMap","existing","updater","isNotSet","existingValue","newValue","nextExisting","nextUpdated","remove","popCount","setIn","array","idx","val","canEdit","newArray","spliceIn","newLen","after","spliceOut","isList","maybeList","IS_LIST_SENTINEL","iterateList","list","iterateNodeOrLeaf","level","iterateLeaf","iterateNode","tailPos","tail","left","to","right","DONE","_origin","_capacity","getTailOffset","_tail","_level","makeList","origin","capacity","ListPrototype","emptyList","EMPTY_LIST","updateList","setListBounds","newTail","updateVNode","nodeHas","lowerNode","newLowerNode","editableVNode","VNode","listNodeFor","rawIndex","owner","oldOrigin","oldCapacity","newOrigin","newCapacity","clear","newLevel","offsetShift","oldTailOffset","newTailOffset","oldTail","removeAfter","removeBefore","beginIndex","mergeIntoListWith","maxSize","setSize","isOrderedMap","maybeOrderedMap","makeOrderedMap","omap","_map","_list","emptyOrderedMap","EMPTY_ORDERED_MAP","updateOrderedMap","newMap","newList","isStack","maybeStack","IS_STACK_SENTINEL","makeStack","head","StackPrototype","_head","emptyStack","EMPTY_STACK","deepEqual","notAssociative","flipped","_","allEqual","bSize","mixin","ctor","methods","keyCopier","keys","getOwnPropertySymbols","isSet","maybeSet","IS_SET_SENTINEL","updateSet","__empty","__make","makeSet","SetPrototype","emptySet","EMPTY_SET","reduction","useFirst","keyMapper","entryMapper","toJS","not","neg","defaultZipper","defaultNegComparator","hashCollection","ordered","keyed","murmurHashOfSize","hashMerge","imul","isOrderedSet","maybeOrderedSet","makeOrderedSet","OrderedSetPrototype","emptyOrderedSet","EMPTY_ORDERED_SET","makeRecord","likeRecord","record","getPrototypeOf","_values","recordName","_name","recordSeq","_keys","setProp","__proto__","Keyed","Indexed","Set","Symbol","ITERATOR_SYMBOL","KEYS","VALUES","ENTRIES","inspect","toSource","Collection$$1","of","__toString","_cache","entrySeq","cache","toIndexedSeq","_array","_object","_collection","_iterator","_iteratorCache","e","WeakMap","ToKeyedSequence","KeyedSeq$$1","indexed","_useKeys","valueSeq","ToIndexedSequence","IndexedSeq$$1","ToSetSequence","SetSeq$$1","FromEntriesSequence","indexedCollection","KeyedCollection$$1","keyValues","updateIn","deleteIn","lastKey","deleteAll","updatedValue","merge","mergeWith","mergeIn","mergeDeepIn","sortBy","mutable","wasAltered","__ensureOwner","MapIterator","iterate","removeIn","removeAll","removed","exists","MAX_ARRAY_MAP_SIZE","isEditable","newEntries","keyHashFrag","MAX_BITMAP_INDEXED_SIZE","newBitmap","newNodes","newCount","MIN_HASH_ARRAY_MAP_SIZE","keyMatch","maxIndex","Iterator$$1","_type","_reverse","_stack","subNode","List","IndexedCollection$$1","empty","splice","insert","oldSize","unshift","originIndex","newChild","removingFirst","oldChild","editable","sizeIndex","Map$$1","Stack","pushAll","peek","arguments$1","unshiftAll","SetCollection$$1","add","fromKeys","keySeq","intersect","sets","union","toRemove","subtract","OrderedSet","EMPTY_RANGE","Range","start","abs","_start","_end","_step","ceil","searchValue","possibleIndex","floor","offsetValue","lastIndexOf","other","isIterable","toJSON","toObject","toOrderedMap","toOrderedSet","toSet","toStack","__toStringMapper","join","returnValue","find","findEntry","sideEffect","bind","joined","isFirst","initialReduction","reduceRight","butLast","isEmpty","countBy","entriesSequence","filterNot","found","findKey","findLast","findLastEntry","findLastKey","first","flatMap","searchKey","getIn","searchKeyPath","nested","groupBy","hasIn","isSubset","isSuperset","keyOf","last","lastKeyOf","maxBy","minBy","rest","skip","amount","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","CollectionPrototype","chain","contains","mapEntries","mapKeys","KeyedCollectionPrototype","findIndex","removeNum","numArgs","spliced","findLastIndex","interpose","interleave","zipped","interleaved","zip","zipWith","IndexedCollectionPrototype","Set$$1","Record","defaultValues","hasInitialized","RecordType","indices","RecordTypePrototype","_indices","_defaultValues","propName","console","warn","RecordPrototype","str","newValues","getDescriptiveName","EMPTY_REPEAT","Repeat","times","_value","Immutable","Iterable"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"redux-pipe\"] = factory();\n\telse\n\t\troot[\"redux-pipe\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"redux-pipe\"] = factory();\n\telse\n\t\troot[\"redux-pipe\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.selectorPipe = exports.selector = exports.branchIf = exports.pipe = undefined;\n\nvar _immutable = __webpack_require__(2);\n\nvar _helpers = __webpack_require__(1);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar pipe = exports.pipe = function pipe(arrayOfMutators, state) {\n  var errorInFirstParam = (0, _helpers.isFirstParamArray)(arrayOfMutators);\n  if (errorInFirstParam) throw errorInFirstParam;\n  return (0, _immutable.isImmutable)(state) ? state.withMutations(function (s) {\n    return (0, _helpers.reduceState)(arrayOfMutators, s);\n  }) : (0, _helpers.reduceState)(arrayOfMutators, state);\n};\n\nvar branchIf = exports.branchIf = function branchIf(predicate, returnIfTrue, returnIfFalse) {\n  return function (state) {\n    var runIfTrue = Array.isArray(returnIfTrue) ? pipe(returnIfTrue, state) : returnIfTrue(state);\n    var runIfFalse = returnIfFalse && (Array.isArray(returnIfFalse) ? pipe(returnIfFalse, state) : returnIfFalse(state));\n    if (returnIfFalse) return predicate(state) ? runIfTrue : runIfFalse;\n    return predicate(state) ? runIfTrue : state;\n  };\n};\n\nvar selector = exports.selector = function selector(reducer, action) {\n  return reducer[action.type] ? reducer[action.type](action) : reducer.DEFAULT();\n};\n\nvar selectorPipe = exports.selectorPipe = function selectorPipe(reducer, state, action) {\n  var globalMutators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n  return reducer[action.type] ? pipe([].concat(_toConsumableArray(reducer[action.type](action)), _toConsumableArray(globalMutators)), state) : reducer.DEFAULT();\n};\n\nvar createGroupMutator = function createGroupMutator(arrayOfMutators, action) {\n  return function (state) {\n    return arrayOfMutators.map(function (mutator) {\n      return mutator(action);\n    }).reduce(function (state, mutator) {\n      return mutator(state);\n    }, state);\n  };\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar isFirstParamArray = exports.isFirstParamArray = function isFirstParamArray(arrayOfMutators) {\n  return Array.isArray(arrayOfMutators) ? false : new Error('First parameter of pipe must be an array');\n};\n\nvar reduceState = exports.reduceState = function reduceState(arrayOfMutators, state) {\n  return arrayOfMutators.reduce(function (state, mutator) {\n    return mutator(state);\n  }, state);\n};\n\nvar areAllFunctions = exports.areAllFunctions = function areAllFunctions(arrayOfFunctions) {\n  return arrayOfFunctions.every(function (func) {\n    return typeof func === 'function';\n  }) ? false : new Error('All parameters of branchIf must be functions');\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n\t true ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.Immutable = global.Immutable || {})));\n}(this, (function (exports) { 'use strict';\n\n// Used for setting prototype methods that IE8 chokes on.\nvar DELETE = 'delete';\n\n// Constants describing the size of trie nodes.\nvar SHIFT = 5; // Resulted in best performance after ______?\nvar SIZE = 1 << SHIFT;\nvar MASK = SIZE - 1;\n\n// A consistent shared value representing \"not set\" which equals nothing other\n// than itself, and nothing that could be provided externally.\nvar NOT_SET = {};\n\n// Boolean references, Rough equivalent of `bool &`.\nvar CHANGE_LENGTH = { value: false };\nvar DID_ALTER = { value: false };\n\nfunction MakeRef(ref) {\n  ref.value = false;\n  return ref;\n}\n\nfunction SetRef(ref) {\n  ref && (ref.value = true);\n}\n\n// A function which returns a value representing an \"owner\" for transient writes\n// to tries. The return value will only ever equal itself, and will not equal\n// the return of any subsequent call of this function.\nfunction OwnerID() {}\n\n// http://jsperf.com/copy-array-inline\nfunction arrCopy(arr, offset) {\n  offset = offset || 0;\n  var len = Math.max(0, arr.length - offset);\n  var newArr = new Array(len);\n  for (var ii = 0; ii < len; ii++) {\n    newArr[ii] = arr[ii + offset];\n  }\n  return newArr;\n}\n\nfunction ensureSize(iter) {\n  if (iter.size === undefined) {\n    iter.size = iter.__iterate(returnTrue);\n  }\n  return iter.size;\n}\n\nfunction wrapIndex(iter, index) {\n  // This implements \"is array index\" which the ECMAString spec defines as:\n  //\n  //     A String property name P is an array index if and only if\n  //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n  //     to 2^32−1.\n  //\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n  if (typeof index !== 'number') {\n    var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n    if ('' + uint32Index !== index || uint32Index === 4294967295) {\n      return NaN;\n    }\n    index = uint32Index;\n  }\n  return index < 0 ? ensureSize(iter) + index : index;\n}\n\nfunction returnTrue() {\n  return true;\n}\n\nfunction wholeSlice(begin, end, size) {\n  return (begin === 0 || (size !== undefined && begin <= -size)) &&\n    (end === undefined || (size !== undefined && end >= size));\n}\n\nfunction resolveBegin(begin, size) {\n  return resolveIndex(begin, size, 0);\n}\n\nfunction resolveEnd(end, size) {\n  return resolveIndex(end, size, size);\n}\n\nfunction resolveIndex(index, size, defaultIndex) {\n  // Sanitize indices using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  return index === undefined\n    ? defaultIndex\n    : index < 0\n        ? size === Infinity ? size : Math.max(0, size + index) | 0\n        : size === undefined || size === index\n            ? index\n            : Math.min(size, index) | 0;\n}\n\nfunction isImmutable(maybeImmutable) {\n  return (isCollection(maybeImmutable) || isRecord(maybeImmutable)) &&\n    !maybeImmutable.__ownerID;\n}\n\nfunction isCollection(maybeCollection) {\n  return !!(maybeCollection && maybeCollection[IS_ITERABLE_SENTINEL]);\n}\n\nfunction isKeyed(maybeKeyed) {\n  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n}\n\nfunction isIndexed(maybeIndexed) {\n  return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n}\n\nfunction isAssociative(maybeAssociative) {\n  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n}\n\nfunction isOrdered(maybeOrdered) {\n  return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n}\n\nfunction isRecord(maybeRecord) {\n  return !!(maybeRecord && maybeRecord[IS_RECORD_SENTINEL]);\n}\n\nfunction isValueObject(maybeValue) {\n  return !!(maybeValue &&\n    typeof maybeValue.equals === 'function' &&\n    typeof maybeValue.hashCode === 'function');\n}\n\nvar IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\nvar IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\nvar IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\nvar IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\nvar IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@';\n\nvar Collection = function Collection(value) {\n  return isCollection(value) ? value : Seq(value);\n};\n\nvar KeyedCollection = (function (Collection) {\n  function KeyedCollection(value) {\n    return isKeyed(value) ? value : KeyedSeq(value);\n  }\n\n  if ( Collection ) KeyedCollection.__proto__ = Collection;\n  KeyedCollection.prototype = Object.create( Collection && Collection.prototype );\n  KeyedCollection.prototype.constructor = KeyedCollection;\n\n  return KeyedCollection;\n}(Collection));\n\nvar IndexedCollection = (function (Collection) {\n  function IndexedCollection(value) {\n    return isIndexed(value) ? value : IndexedSeq(value);\n  }\n\n  if ( Collection ) IndexedCollection.__proto__ = Collection;\n  IndexedCollection.prototype = Object.create( Collection && Collection.prototype );\n  IndexedCollection.prototype.constructor = IndexedCollection;\n\n  return IndexedCollection;\n}(Collection));\n\nvar SetCollection = (function (Collection) {\n  function SetCollection(value) {\n    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n  }\n\n  if ( Collection ) SetCollection.__proto__ = Collection;\n  SetCollection.prototype = Object.create( Collection && Collection.prototype );\n  SetCollection.prototype.constructor = SetCollection;\n\n  return SetCollection;\n}(Collection));\n\nCollection.Keyed = KeyedCollection;\nCollection.Indexed = IndexedCollection;\nCollection.Set = SetCollection;\n\nvar ITERATE_KEYS = 0;\nvar ITERATE_VALUES = 1;\nvar ITERATE_ENTRIES = 2;\n\nvar REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nvar ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\nvar Iterator = function Iterator(next) {\n  this.next = next;\n};\n\nIterator.prototype.toString = function toString () {\n  return '[Iterator]';\n};\n\nIterator.KEYS = ITERATE_KEYS;\nIterator.VALUES = ITERATE_VALUES;\nIterator.ENTRIES = ITERATE_ENTRIES;\n\nIterator.prototype.inspect = (Iterator.prototype.toSource = function() {\n  return this.toString();\n});\nIterator.prototype[ITERATOR_SYMBOL] = function() {\n  return this;\n};\n\nfunction iteratorValue(type, k, v, iteratorResult) {\n  var value = type === 0 ? k : type === 1 ? v : [k, v];\n  iteratorResult\n    ? (iteratorResult.value = value)\n    : (iteratorResult = {\n        value: value,\n        done: false\n      });\n  return iteratorResult;\n}\n\nfunction iteratorDone() {\n  return { value: undefined, done: true };\n}\n\nfunction hasIterator(maybeIterable) {\n  return !!getIteratorFn(maybeIterable);\n}\n\nfunction isIterator(maybeIterator) {\n  return maybeIterator && typeof maybeIterator.next === 'function';\n}\n\nfunction getIterator(iterable) {\n  var iteratorFn = getIteratorFn(iterable);\n  return iteratorFn && iteratorFn.call(iterable);\n}\n\nfunction getIteratorFn(iterable) {\n  var iteratorFn = iterable &&\n    ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]);\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n}\n\nfunction isArrayLike(value) {\n  return value && typeof value.length === 'number';\n}\n\nvar Seq = (function (Collection$$1) {\n  function Seq(value) {\n    return value === null || value === undefined\n      ? emptySequence()\n      : isCollection(value) || isRecord(value)\n          ? value.toSeq()\n          : seqFromValue(value);\n  }\n\n  if ( Collection$$1 ) Seq.__proto__ = Collection$$1;\n  Seq.prototype = Object.create( Collection$$1 && Collection$$1.prototype );\n  Seq.prototype.constructor = Seq;\n\n  Seq.of = function of (/*...values*/) {\n    return Seq(arguments);\n  };\n\n  Seq.prototype.toSeq = function toSeq () {\n    return this;\n  };\n\n  Seq.prototype.toString = function toString () {\n    return this.__toString('Seq {', '}');\n  };\n\n  Seq.prototype.cacheResult = function cacheResult () {\n    if (!this._cache && this.__iterateUncached) {\n      this._cache = this.entrySeq().toArray();\n      this.size = this._cache.length;\n    }\n    return this;\n  };\n\n  // abstract __iterateUncached(fn, reverse)\n\n  Seq.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      while (i !== size) {\n        var entry = cache[reverse ? size - ++i : i++];\n        if (fn(entry[1], entry[0], this$1) === false) {\n          break;\n        }\n      }\n      return i;\n    }\n    return this.__iterateUncached(fn, reverse);\n  };\n\n  // abstract __iteratorUncached(type, reverse)\n\n  Seq.prototype.__iterator = function __iterator (type, reverse) {\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var entry = cache[reverse ? size - ++i : i++];\n        return iteratorValue(type, entry[0], entry[1]);\n      });\n    }\n    return this.__iteratorUncached(type, reverse);\n  };\n\n  return Seq;\n}(Collection));\n\nvar KeyedSeq = (function (Seq) {\n  function KeyedSeq(value) {\n    return value === null || value === undefined\n      ? emptySequence().toKeyedSeq()\n      : isCollection(value)\n          ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq()\n          : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);\n  }\n\n  if ( Seq ) KeyedSeq.__proto__ = Seq;\n  KeyedSeq.prototype = Object.create( Seq && Seq.prototype );\n  KeyedSeq.prototype.constructor = KeyedSeq;\n\n  KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {\n    return this;\n  };\n\n  return KeyedSeq;\n}(Seq));\n\nvar IndexedSeq = (function (Seq) {\n  function IndexedSeq(value) {\n    return value === null || value === undefined\n      ? emptySequence()\n      : isCollection(value)\n          ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq()\n          : isRecord(value)\n              ? value.toSeq().entrySeq()\n              : indexedSeqFromValue(value);\n  }\n\n  if ( Seq ) IndexedSeq.__proto__ = Seq;\n  IndexedSeq.prototype = Object.create( Seq && Seq.prototype );\n  IndexedSeq.prototype.constructor = IndexedSeq;\n\n  IndexedSeq.of = function of (/*...values*/) {\n    return IndexedSeq(arguments);\n  };\n\n  IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {\n    return this;\n  };\n\n  IndexedSeq.prototype.toString = function toString () {\n    return this.__toString('Seq [', ']');\n  };\n\n  return IndexedSeq;\n}(Seq));\n\nvar SetSeq = (function (Seq) {\n  function SetSeq(value) {\n    return (isCollection(value) && !isAssociative(value)\n      ? value\n      : IndexedSeq(value)).toSetSeq();\n  }\n\n  if ( Seq ) SetSeq.__proto__ = Seq;\n  SetSeq.prototype = Object.create( Seq && Seq.prototype );\n  SetSeq.prototype.constructor = SetSeq;\n\n  SetSeq.of = function of (/*...values*/) {\n    return SetSeq(arguments);\n  };\n\n  SetSeq.prototype.toSetSeq = function toSetSeq () {\n    return this;\n  };\n\n  return SetSeq;\n}(Seq));\n\nSeq.isSeq = isSeq;\nSeq.Keyed = KeyedSeq;\nSeq.Set = SetSeq;\nSeq.Indexed = IndexedSeq;\n\nvar IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\nSeq.prototype[IS_SEQ_SENTINEL] = true;\n\n// #pragma Root Sequences\n\nvar ArraySeq = (function (IndexedSeq) {\n  function ArraySeq(array) {\n    this._array = array;\n    this.size = array.length;\n  }\n\n  if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;\n  ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  ArraySeq.prototype.constructor = ArraySeq;\n\n  ArraySeq.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n  };\n\n  ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    while (i !== size) {\n      var ii = reverse ? size - ++i : i++;\n      if (fn(array[ii], ii, this$1) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ArraySeq.prototype.__iterator = function __iterator (type, reverse) {\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var ii = reverse ? size - ++i : i++;\n      return iteratorValue(type, ii, array[ii]);\n    });\n  };\n\n  return ArraySeq;\n}(IndexedSeq));\n\nvar ObjectSeq = (function (KeyedSeq) {\n  function ObjectSeq(object) {\n    var keys = Object.keys(object);\n    this._object = object;\n    this._keys = keys;\n    this.size = keys.length;\n  }\n\n  if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;\n  ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n  ObjectSeq.prototype.constructor = ObjectSeq;\n\n  ObjectSeq.prototype.get = function get (key, notSetValue) {\n    if (notSetValue !== undefined && !this.has(key)) {\n      return notSetValue;\n    }\n    return this._object[key];\n  };\n\n  ObjectSeq.prototype.has = function has (key) {\n    return this._object.hasOwnProperty(key);\n  };\n\n  ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    while (i !== size) {\n      var key = keys[reverse ? size - ++i : i++];\n      if (fn(object[key], key, this$1) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var key = keys[reverse ? size - ++i : i++];\n      return iteratorValue(type, key, object[key]);\n    });\n  };\n\n  return ObjectSeq;\n}(KeyedSeq));\nObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\nvar CollectionSeq = (function (IndexedSeq) {\n  function CollectionSeq(collection) {\n    this._collection = collection;\n    this.size = collection.length || collection.size;\n  }\n\n  if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;\n  CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  CollectionSeq.prototype.constructor = CollectionSeq;\n\n  CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    var iterations = 0;\n    if (isIterator(iterator)) {\n      var step;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this$1) === false) {\n          break;\n        }\n      }\n    }\n    return iterations;\n  };\n\n  CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    if (!isIterator(iterator)) {\n      return new Iterator(iteratorDone);\n    }\n    var iterations = 0;\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done ? step : iteratorValue(type, iterations++, step.value);\n    });\n  };\n\n  return CollectionSeq;\n}(IndexedSeq));\n\nvar IteratorSeq = (function (IndexedSeq) {\n  function IteratorSeq(iterator) {\n    this._iterator = iterator;\n    this._iteratorCache = [];\n  }\n\n  if ( IndexedSeq ) IteratorSeq.__proto__ = IndexedSeq;\n  IteratorSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  IteratorSeq.prototype.constructor = IteratorSeq;\n\n  IteratorSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterator = this._iterator;\n    var cache = this._iteratorCache;\n    var iterations = 0;\n    while (iterations < cache.length) {\n      if (fn(cache[iterations], iterations++, this$1) === false) {\n        return iterations;\n      }\n    }\n    var step;\n    while (!(step = iterator.next()).done) {\n      var val = step.value;\n      cache[iterations] = val;\n      if (fn(val, iterations++, this$1) === false) {\n        break;\n      }\n    }\n    return iterations;\n  };\n\n  IteratorSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = this._iterator;\n    var cache = this._iteratorCache;\n    var iterations = 0;\n    return new Iterator(function () {\n      if (iterations >= cache.length) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        cache[iterations] = step.value;\n      }\n      return iteratorValue(type, iterations, cache[iterations++]);\n    });\n  };\n\n  return IteratorSeq;\n}(IndexedSeq));\n\n// # pragma Helper functions\n\nfunction isSeq(maybeSeq) {\n  return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n}\n\nvar EMPTY_SEQ;\n\nfunction emptySequence() {\n  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n}\n\nfunction keyedSeqFromValue(value) {\n  var seq = Array.isArray(value)\n    ? new ArraySeq(value)\n    : isIterator(value)\n        ? new IteratorSeq(value)\n        : hasIterator(value) ? new CollectionSeq(value) : undefined;\n  if (seq) {\n    return seq.fromEntrySeq();\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of [k, v] entries, or keyed object: ' +\n      value\n  );\n}\n\nfunction indexedSeqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq;\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values: ' + value\n  );\n}\n\nfunction seqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq;\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values, or keyed object: ' + value\n  );\n}\n\nfunction maybeIndexedSeqFromValue(value) {\n  return isArrayLike(value)\n    ? new ArraySeq(value)\n    : isIterator(value)\n        ? new IteratorSeq(value)\n        : hasIterator(value) ? new CollectionSeq(value) : undefined;\n}\n\n/**\n * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n *\n * NaN is considered the same as NaN, however -0 and 0 are considered the same\n * value, which is different from the algorithm described by\n * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n *\n * This is extended further to allow Objects to describe the values they\n * represent, by way of `valueOf` or `equals` (and `hashCode`).\n *\n * Note: because of this extension, the key equality of Immutable.Map and the\n * value equality of Immutable.Set will differ from ES6 Map and Set.\n *\n * ### Defining custom values\n *\n * The easiest way to describe the value an object represents is by implementing\n * `valueOf`. For example, `Date` represents a value by returning a unix\n * timestamp for `valueOf`:\n *\n *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n *     var date2 = new Date(1234567890000);\n *     date1.valueOf(); // 1234567890000\n *     assert( date1 !== date2 );\n *     assert( Immutable.is( date1, date2 ) );\n *\n * Note: overriding `valueOf` may have other implications if you use this object\n * where JavaScript expects a primitive, such as implicit string coercion.\n *\n * For more complex types, especially collections, implementing `valueOf` may\n * not be performant. An alternative is to implement `equals` and `hashCode`.\n *\n * `equals` takes another object, presumably of similar type, and returns true\n * if it is equal. Equality is symmetrical, so the same result should be\n * returned if this and the argument are flipped.\n *\n *     assert( a.equals(b) === b.equals(a) );\n *\n * `hashCode` returns a 32bit integer number representing the object which will\n * be used to determine how to store the value object in a Map or Set. You must\n * provide both or neither methods, one must not exist without the other.\n *\n * Also, an important relationship between these methods must be upheld: if two\n * values are equal, they *must* return the same hashCode. If the values are not\n * equal, they might have the same hashCode; this is called a hash collision,\n * and while undesirable for performance reasons, it is acceptable.\n *\n *     if (a.equals(b)) {\n *       assert( a.hashCode() === b.hashCode() );\n *     }\n *\n * All Immutable collections are Value Objects: they implement `equals()`\n * and `hashCode()`.\n */\nfunction is(valueA, valueB) {\n  if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n    return true;\n  }\n  if (!valueA || !valueB) {\n    return false;\n  }\n  if (\n    typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function'\n  ) {\n    valueA = valueA.valueOf();\n    valueB = valueB.valueOf();\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n  }\n  return !!(isValueObject(valueA) &&\n    isValueObject(valueB) &&\n    valueA.equals(valueB));\n}\n\nfunction fromJS(value, converter) {\n  return fromJSWith(\n    [],\n    converter || defaultConverter,\n    value,\n    '',\n    converter && converter.length > 2 ? [] : undefined,\n    { '': value }\n  );\n}\n\nfunction fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n  var toSeq = Array.isArray(value)\n    ? IndexedSeq\n    : isPlainObj(value) ? KeyedSeq : null;\n  if (toSeq) {\n    if (~stack.indexOf(value)) {\n      throw new TypeError('Cannot convert circular structure to Immutable');\n    }\n    stack.push(value);\n    keyPath && key !== '' && keyPath.push(key);\n    var converted = converter.call(\n      parentValue,\n      key,\n      toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }),\n      keyPath && keyPath.slice()\n    );\n    stack.pop();\n    keyPath && keyPath.pop();\n    return converted;\n  }\n  return value;\n}\n\nfunction defaultConverter(k, v) {\n  return isKeyed(v) ? v.toMap() : v.toList();\n}\n\nfunction isPlainObj(value) {\n  return value &&\n    (value.constructor === Object || value.constructor === undefined);\n}\n\nvar imul = typeof Math.imul === 'function' &&\n  Math.imul(0xffffffff, 2) === -2\n  ? Math.imul\n  : function imul(a, b) {\n      a |= 0; // int\n      b |= 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int\n    };\n\n// v8 has an optimization for storing 31-bit signed numbers.\n// Values which have either 00 or 11 as the high order bits qualify.\n// This function drops the highest order bit in a signed number, maintaining\n// the sign bit.\nfunction smi(i32) {\n  return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;\n}\n\nfunction hash(o) {\n  if (o === false || o === null || o === undefined) {\n    return 0;\n  }\n  if (typeof o.valueOf === 'function') {\n    o = o.valueOf();\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n  }\n  if (o === true) {\n    return 1;\n  }\n  var type = typeof o;\n  if (type === 'number') {\n    if (o !== o || o === Infinity) {\n      return 0;\n    }\n    var h = o | 0;\n    if (h !== o) {\n      h ^= o * 0xffffffff;\n    }\n    while (o > 0xffffffff) {\n      o /= 0xffffffff;\n      h ^= o;\n    }\n    return smi(h);\n  }\n  if (type === 'string') {\n    return o.length > STRING_HASH_CACHE_MIN_STRLEN\n      ? cachedHashString(o)\n      : hashString(o);\n  }\n  if (typeof o.hashCode === 'function') {\n    return o.hashCode();\n  }\n  if (type === 'object') {\n    return hashJSObj(o);\n  }\n  if (typeof o.toString === 'function') {\n    return hashString(o.toString());\n  }\n  throw new Error('Value type ' + type + ' cannot be hashed.');\n}\n\nfunction cachedHashString(string) {\n  var hash = stringHashCache[string];\n  if (hash === undefined) {\n    hash = hashString(string);\n    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n      STRING_HASH_CACHE_SIZE = 0;\n      stringHashCache = {};\n    }\n    STRING_HASH_CACHE_SIZE++;\n    stringHashCache[string] = hash;\n  }\n  return hash;\n}\n\n// http://jsperf.com/hashing-strings\nfunction hashString(string) {\n  // This is the hash from JVM\n  // The hash code for a string is computed as\n  // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n  // where s[i] is the ith character of the string and n is the length of\n  // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n  // (exclusive) by dropping high bits.\n  var hash = 0;\n  for (var ii = 0; ii < string.length; ii++) {\n    hash = 31 * hash + string.charCodeAt(ii) | 0;\n  }\n  return smi(hash);\n}\n\nfunction hashJSObj(obj) {\n  var hash;\n  if (usingWeakMap) {\n    hash = weakMap.get(obj);\n    if (hash !== undefined) {\n      return hash;\n    }\n  }\n\n  hash = obj[UID_HASH_KEY];\n  if (hash !== undefined) {\n    return hash;\n  }\n\n  if (!canDefineProperty) {\n    hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    hash = getIENodeHash(obj);\n    if (hash !== undefined) {\n      return hash;\n    }\n  }\n\n  hash = ++objHashUID;\n  if (objHashUID & 0x40000000) {\n    objHashUID = 0;\n  }\n\n  if (usingWeakMap) {\n    weakMap.set(obj, hash);\n  } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n    throw new Error('Non-extensible objects are not allowed as keys.');\n  } else if (canDefineProperty) {\n    Object.defineProperty(obj, UID_HASH_KEY, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: hash\n    });\n  } else if (\n    obj.propertyIsEnumerable !== undefined &&\n    obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable\n  ) {\n    // Since we can't define a non-enumerable property on the object\n    // we'll hijack one of the less-used non-enumerable properties to\n    // save our hash on it. Since this is a function it will not show up in\n    // `JSON.stringify` which is what we want.\n    obj.propertyIsEnumerable = function() {\n      return this.constructor.prototype.propertyIsEnumerable.apply(\n        this,\n        arguments\n      );\n    };\n    obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n  } else if (obj.nodeType !== undefined) {\n    // At this point we couldn't get the IE `uniqueID` to use as a hash\n    // and we couldn't use a non-enumerable property to exploit the\n    // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n    // itself.\n    obj[UID_HASH_KEY] = hash;\n  } else {\n    throw new Error('Unable to set a non-enumerable property on object.');\n  }\n\n  return hash;\n}\n\n// Get references to ES5 object methods.\nvar isExtensible = Object.isExtensible;\n\n// True if Object.defineProperty works as expected. IE8 fails this test.\nvar canDefineProperty = (function() {\n  try {\n    Object.defineProperty({}, '@', {});\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();\n\n// IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n// and avoid memory leaks from the IE cloneNode bug.\nfunction getIENodeHash(node) {\n  if (node && node.nodeType > 0) {\n    switch (node.nodeType) {\n      case 1: // Element\n        return node.uniqueID;\n      case 9: // Document\n        return node.documentElement && node.documentElement.uniqueID;\n    }\n  }\n}\n\n// If possible, use a WeakMap.\nvar usingWeakMap = typeof WeakMap === 'function';\nvar weakMap;\nif (usingWeakMap) {\n  weakMap = new WeakMap();\n}\n\nvar objHashUID = 0;\n\nvar UID_HASH_KEY = '__immutablehash__';\nif (typeof Symbol === 'function') {\n  UID_HASH_KEY = Symbol(UID_HASH_KEY);\n}\n\nvar STRING_HASH_CACHE_MIN_STRLEN = 16;\nvar STRING_HASH_CACHE_MAX_SIZE = 255;\nvar STRING_HASH_CACHE_SIZE = 0;\nvar stringHashCache = {};\n\nvar ToKeyedSequence = (function (KeyedSeq$$1) {\n  function ToKeyedSequence(indexed, useKeys) {\n    this._iter = indexed;\n    this._useKeys = useKeys;\n    this.size = indexed.size;\n  }\n\n  if ( KeyedSeq$$1 ) ToKeyedSequence.__proto__ = KeyedSeq$$1;\n  ToKeyedSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );\n  ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n  ToKeyedSequence.prototype.get = function get (key, notSetValue) {\n    return this._iter.get(key, notSetValue);\n  };\n\n  ToKeyedSequence.prototype.has = function has (key) {\n    return this._iter.has(key);\n  };\n\n  ToKeyedSequence.prototype.valueSeq = function valueSeq () {\n    return this._iter.valueSeq();\n  };\n\n  ToKeyedSequence.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var reversedSequence = reverseFactory(this, true);\n    if (!this._useKeys) {\n      reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };\n    }\n    return reversedSequence;\n  };\n\n  ToKeyedSequence.prototype.map = function map (mapper, context) {\n    var this$1 = this;\n\n    var mappedSequence = mapFactory(this, mapper, context);\n    if (!this._useKeys) {\n      mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };\n    }\n    return mappedSequence;\n  };\n\n  ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);\n  };\n\n  ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    return this._iter.__iterator(type, reverse);\n  };\n\n  return ToKeyedSequence;\n}(KeyedSeq));\nToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\nvar ToIndexedSequence = (function (IndexedSeq$$1) {\n  function ToIndexedSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( IndexedSeq$$1 ) ToIndexedSequence.__proto__ = IndexedSeq$$1;\n  ToIndexedSequence.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n  ToIndexedSequence.prototype.includes = function includes (value) {\n    return this._iter.includes(value);\n  };\n\n  ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(this);\n    return this._iter.__iterate(\n      function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },\n      reverse\n    );\n  };\n\n  ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1 = this;\n\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    var i = 0;\n    reverse && ensureSize(this);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(\n            type,\n            reverse ? this$1.size - ++i : i++,\n            step.value,\n            step\n          );\n    });\n  };\n\n  return ToIndexedSequence;\n}(IndexedSeq));\n\nvar ToSetSequence = (function (SetSeq$$1) {\n  function ToSetSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( SetSeq$$1 ) ToSetSequence.__proto__ = SetSeq$$1;\n  ToSetSequence.prototype = Object.create( SetSeq$$1 && SetSeq$$1.prototype );\n  ToSetSequence.prototype.constructor = ToSetSequence;\n\n  ToSetSequence.prototype.has = function has (key) {\n    return this._iter.includes(key);\n  };\n\n  ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);\n  };\n\n  ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(type, step.value, step.value, step);\n    });\n  };\n\n  return ToSetSequence;\n}(SetSeq));\n\nvar FromEntriesSequence = (function (KeyedSeq$$1) {\n  function FromEntriesSequence(entries) {\n    this._iter = entries;\n    this.size = entries.size;\n  }\n\n  if ( KeyedSeq$$1 ) FromEntriesSequence.__proto__ = KeyedSeq$$1;\n  FromEntriesSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );\n  FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n  FromEntriesSequence.prototype.entrySeq = function entrySeq () {\n    return this._iter.toSeq();\n  };\n\n  FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(\n      function (entry) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return fn(\n            indexedCollection ? entry.get(1) : entry[1],\n            indexedCollection ? entry.get(0) : entry[0],\n            this$1\n          );\n        }\n      },\n      reverse\n    );\n  };\n\n  FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return iteratorValue(\n            type,\n            indexedCollection ? entry.get(0) : entry[0],\n            indexedCollection ? entry.get(1) : entry[1],\n            step\n          );\n        }\n      }\n    });\n  };\n\n  return FromEntriesSequence;\n}(KeyedSeq));\n\nToIndexedSequence.prototype.cacheResult = (ToKeyedSequence.prototype.cacheResult = (ToSetSequence.prototype.cacheResult = (FromEntriesSequence.prototype.cacheResult = cacheResultThrough)));\n\nfunction flipFactory(collection) {\n  var flipSequence = makeSequence(collection);\n  flipSequence._iter = collection;\n  flipSequence.size = collection.size;\n  flipSequence.flip = function () { return collection; };\n  flipSequence.reverse = function() {\n    var reversedSequence = collection.reverse.apply(this); // super.reverse()\n    reversedSequence.flip = function () { return collection.reverse(); };\n    return reversedSequence;\n  };\n  flipSequence.has = function (key) { return collection.includes(key); };\n  flipSequence.includes = function (key) { return collection.has(key); };\n  flipSequence.cacheResult = cacheResultThrough;\n  flipSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);\n  };\n  flipSequence.__iteratorUncached = function(type, reverse) {\n    if (type === ITERATE_ENTRIES) {\n      var iterator = collection.__iterator(type, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (!step.done) {\n          var k = step.value[0];\n          step.value[0] = step.value[1];\n          step.value[1] = k;\n        }\n        return step;\n      });\n    }\n    return collection.__iterator(\n      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n      reverse\n    );\n  };\n  return flipSequence;\n}\n\nfunction mapFactory(collection, mapper, context) {\n  var mappedSequence = makeSequence(collection);\n  mappedSequence.size = collection.size;\n  mappedSequence.has = function (key) { return collection.has(key); };\n  mappedSequence.get = function (key, notSetValue) {\n    var v = collection.get(key, NOT_SET);\n    return v === NOT_SET\n      ? notSetValue\n      : mapper.call(context, v, key, collection);\n  };\n  mappedSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    return collection.__iterate(\n      function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },\n      reverse\n    );\n  };\n  mappedSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var key = entry[0];\n      return iteratorValue(\n        type,\n        key,\n        mapper.call(context, entry[1], key, collection),\n        step\n      );\n    });\n  };\n  return mappedSequence;\n}\n\nfunction reverseFactory(collection, useKeys) {\n  var this$1 = this;\n\n  var reversedSequence = makeSequence(collection);\n  reversedSequence._iter = collection;\n  reversedSequence.size = collection.size;\n  reversedSequence.reverse = function () { return collection; };\n  if (collection.flip) {\n    reversedSequence.flip = function() {\n      var flipSequence = flipFactory(collection);\n      flipSequence.reverse = function () { return collection.flip(); };\n      return flipSequence;\n    };\n  }\n  reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };\n  reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };\n  reversedSequence.includes = function (value) { return collection.includes(value); };\n  reversedSequence.cacheResult = cacheResultThrough;\n  reversedSequence.__iterate = function(fn, reverse) {\n    var this$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(collection);\n    return collection.__iterate(\n      function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },\n      !reverse\n    );\n  };\n  reversedSequence.__iterator = function (type, reverse) {\n    var i = 0;\n    reverse && ensureSize(collection);\n    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      return iteratorValue(\n        type,\n        useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,\n        entry[1],\n        step\n      );\n    });\n  };\n  return reversedSequence;\n}\n\nfunction filterFactory(collection, predicate, context, useKeys) {\n  var filterSequence = makeSequence(collection);\n  if (useKeys) {\n    filterSequence.has = function (key) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n    };\n    filterSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && predicate.call(context, v, key, collection)\n        ? v\n        : notSetValue;\n    };\n  }\n  filterSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(\n      function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          return fn(v, useKeys ? k : iterations++, this$1);\n        }\n      },\n      reverse\n    );\n    return iterations;\n  };\n  filterSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterations = 0;\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        var value = entry[1];\n        if (predicate.call(context, value, key, collection)) {\n          return iteratorValue(type, useKeys ? key : iterations++, value, step);\n        }\n      }\n    });\n  };\n  return filterSequence;\n}\n\nfunction countByFactory(collection, grouper, context) {\n  var groups = Map().asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });\n  });\n  return groups.asImmutable();\n}\n\nfunction groupByFactory(collection, grouper, context) {\n  var isKeyedIter = isKeyed(collection);\n  var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(\n      grouper.call(context, v, k, collection),\n      function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }\n    );\n  });\n  var coerce = collectionClass(collection);\n  return groups.map(function (arr) { return reify(collection, coerce(arr)); });\n}\n\nfunction sliceFactory(collection, begin, end, useKeys) {\n  var originalSize = collection.size;\n\n  if (wholeSlice(begin, end, originalSize)) {\n    return collection;\n  }\n\n  var resolvedBegin = resolveBegin(begin, originalSize);\n  var resolvedEnd = resolveEnd(end, originalSize);\n\n  // begin or end will be NaN if they were provided as negative numbers and\n  // this collection's size is unknown. In that case, cache first so there is\n  // a known size and these do not resolve to NaN.\n  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n  }\n\n  // Note: resolvedEnd is undefined when the original sequence's length is\n  // unknown and this slice did not supply an end and should contain all\n  // elements after resolvedBegin.\n  // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n  var resolvedSize = resolvedEnd - resolvedBegin;\n  var sliceSize;\n  if (resolvedSize === resolvedSize) {\n    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n  }\n\n  var sliceSeq = makeSequence(collection);\n\n  // If collection.size is undefined, the size of the realized sliceSeq is\n  // unknown at this point unless the number of items to slice is 0\n  sliceSeq.size = sliceSize === 0\n    ? sliceSize\n    : (collection.size && sliceSize) || undefined;\n\n  if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n    sliceSeq.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index >= 0 && index < sliceSize\n        ? collection.get(index + resolvedBegin, notSetValue)\n        : notSetValue;\n    };\n  }\n\n  sliceSeq.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (sliceSize === 0) {\n      return 0;\n    }\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var skipped = 0;\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k) {\n      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1) !== false &&\n          iterations !== sliceSize;\n      }\n    });\n    return iterations;\n  };\n\n  sliceSeq.__iteratorUncached = function(type, reverse) {\n    if (sliceSize !== 0 && reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    // Don't bother instantiating parent iterator if taking 0.\n    var iterator = sliceSize !== 0 && collection.__iterator(type, reverse);\n    var skipped = 0;\n    var iterations = 0;\n    return new Iterator(function () {\n      while (skipped++ < resolvedBegin) {\n        iterator.next();\n      }\n      if (++iterations > sliceSize) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (useKeys || type === ITERATE_VALUES) {\n        return step;\n      }\n      if (type === ITERATE_KEYS) {\n        return iteratorValue(type, iterations - 1, undefined, step);\n      }\n      return iteratorValue(type, iterations - 1, step.value[1], step);\n    });\n  };\n\n  return sliceSeq;\n}\n\nfunction takeWhileFactory(collection, predicate, context) {\n  var takeSequence = makeSequence(collection);\n  takeSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    collection.__iterate(\n      function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }\n    );\n    return iterations;\n  };\n  takeSequence.__iteratorUncached = function(type, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterating = true;\n    return new Iterator(function () {\n      if (!iterating) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var k = entry[0];\n      var v = entry[1];\n      if (!predicate.call(context, v, k, this$1)) {\n        iterating = false;\n        return iteratorDone();\n      }\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return takeSequence;\n}\n\nfunction skipWhileFactory(collection, predicate, context, useKeys) {\n  var skipSequence = makeSequence(collection);\n  skipSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k, c) {\n      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1);\n      }\n    });\n    return iterations;\n  };\n  skipSequence.__iteratorUncached = function(type, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var skipping = true;\n    var iterations = 0;\n    return new Iterator(function () {\n      var step;\n      var k;\n      var v;\n      do {\n        step = iterator.next();\n        if (step.done) {\n          if (useKeys || type === ITERATE_VALUES) {\n            return step;\n          }\n          if (type === ITERATE_KEYS) {\n            return iteratorValue(type, iterations++, undefined, step);\n          }\n          return iteratorValue(type, iterations++, step.value[1], step);\n        }\n        var entry = step.value;\n        k = entry[0];\n        v = entry[1];\n        skipping && (skipping = predicate.call(context, v, k, this$1));\n      } while (skipping);\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return skipSequence;\n}\n\nfunction concatFactory(collection, values) {\n  var isKeyedCollection = isKeyed(collection);\n  var iters = [collection]\n    .concat(values)\n    .map(function (v) {\n      if (!isCollection(v)) {\n        v = isKeyedCollection\n          ? keyedSeqFromValue(v)\n          : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedCollection) {\n        v = KeyedCollection(v);\n      }\n      return v;\n    })\n    .filter(function (v) { return v.size !== 0; });\n\n  if (iters.length === 0) {\n    return collection;\n  }\n\n  if (iters.length === 1) {\n    var singleton = iters[0];\n    if (\n      singleton === collection ||\n      (isKeyedCollection && isKeyed(singleton)) ||\n      (isIndexed(collection) && isIndexed(singleton))\n    ) {\n      return singleton;\n    }\n  }\n\n  var concatSeq = new ArraySeq(iters);\n  if (isKeyedCollection) {\n    concatSeq = concatSeq.toKeyedSeq();\n  } else if (!isIndexed(collection)) {\n    concatSeq = concatSeq.toSetSeq();\n  }\n  concatSeq = concatSeq.flatten(true);\n  concatSeq.size = iters.reduce(\n    function (sum, seq) {\n      if (sum !== undefined) {\n        var size = seq.size;\n        if (size !== undefined) {\n          return sum + size;\n        }\n      }\n    },\n    0\n  );\n  return concatSeq;\n}\n\nfunction flattenFactory(collection, depth, useKeys) {\n  var flatSequence = makeSequence(collection);\n  flatSequence.__iterateUncached = function(fn, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    var stopped = false;\n    function flatDeep(iter, currentDepth) {\n      iter.__iterate(\n        function (v, k) {\n          if ((!depth || currentDepth < depth) && isCollection(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (\n            fn(v, useKeys ? k : iterations++, flatSequence) === false\n          ) {\n            stopped = true;\n          }\n          return !stopped;\n        },\n        reverse\n      );\n    }\n    flatDeep(collection, 0);\n    return iterations;\n  };\n  flatSequence.__iteratorUncached = function(type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(type, reverse);\n    var stack = [];\n    var iterations = 0;\n    return new Iterator(function () {\n      while (iterator) {\n        var step = iterator.next();\n        if (step.done !== false) {\n          iterator = stack.pop();\n          continue;\n        }\n        var v = step.value;\n        if (type === ITERATE_ENTRIES) {\n          v = v[1];\n        }\n        if ((!depth || stack.length < depth) && isCollection(v)) {\n          stack.push(iterator);\n          iterator = v.__iterator(type, reverse);\n        } else {\n          return useKeys ? step : iteratorValue(type, iterations++, v, step);\n        }\n      }\n      return iteratorDone();\n    });\n  };\n  return flatSequence;\n}\n\nfunction flatMapFactory(collection, mapper, context) {\n  var coerce = collectionClass(collection);\n  return collection\n    .toSeq()\n    .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })\n    .flatten(true);\n}\n\nfunction interposeFactory(collection, separator) {\n  var interposedSequence = makeSequence(collection);\n  interposedSequence.size = collection.size && collection.size * 2 - 1;\n  interposedSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(\n      function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&\n        fn(v, iterations++, this$1) !== false; },\n      reverse\n    );\n    return iterations;\n  };\n  interposedSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n    var iterations = 0;\n    var step;\n    return new Iterator(function () {\n      if (!step || iterations % 2) {\n        step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n      }\n      return iterations % 2\n        ? iteratorValue(type, iterations++, separator)\n        : iteratorValue(type, iterations++, step.value, step);\n    });\n  };\n  return interposedSequence;\n}\n\nfunction sortFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  var isKeyedCollection = isKeyed(collection);\n  var index = 0;\n  var entries = collection\n    .toSeq()\n    .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })\n    .toArray();\n  entries.sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; }).forEach(\n    isKeyedCollection\n      ? function (v, i) {\n          entries[i].length = 2;\n        }\n      : function (v, i) {\n          entries[i] = v[1];\n        }\n  );\n  return isKeyedCollection\n    ? KeyedSeq(entries)\n    : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);\n}\n\nfunction maxFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  if (mapper) {\n    var entry = collection\n      .toSeq()\n      .map(function (v, k) { return [v, mapper(v, k, collection)]; })\n      .reduce(function (a, b) { return maxCompare(comparator, a[1], b[1]) ? b : a; });\n    return entry && entry[0];\n  }\n  return collection.reduce(function (a, b) { return maxCompare(comparator, a, b) ? b : a; });\n}\n\nfunction maxCompare(comparator, a, b) {\n  var comp = comparator(b, a);\n  // b is considered the new max if the comparator declares them equal, but\n  // they are not equal and b is in fact a nullish value.\n  return (comp === 0 &&\n    b !== a &&\n    (b === undefined || b === null || b !== b)) ||\n    comp > 0;\n}\n\nfunction zipWithFactory(keyIter, zipper, iters) {\n  var zipSequence = makeSequence(keyIter);\n  zipSequence.size = new ArraySeq(iters).map(function (i) { return i.size; }).min();\n  // Note: this a generic base implementation of __iterate in terms of\n  // __iterator which may be more generically useful in the future.\n  zipSequence.__iterate = function(fn, reverse) {\n    var this$1 = this;\n\n    /* generic:\n    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      iterations++;\n      if (fn(step.value[1], step.value[0], this) === false) {\n        break;\n      }\n    }\n    return iterations;\n    */\n    // indexed:\n    var iterator = this.__iterator(ITERATE_VALUES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      if (fn(step.value, iterations++, this$1) === false) {\n        break;\n      }\n    }\n    return iterations;\n  };\n  zipSequence.__iteratorUncached = function(type, reverse) {\n    var iterators = iters.map(\n      function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }\n    );\n    var iterations = 0;\n    var isDone = false;\n    return new Iterator(function () {\n      var steps;\n      if (!isDone) {\n        steps = iterators.map(function (i) { return i.next(); });\n        isDone = steps.some(function (s) { return s.done; });\n      }\n      if (isDone) {\n        return iteratorDone();\n      }\n      return iteratorValue(\n        type,\n        iterations++,\n        zipper.apply(null, steps.map(function (s) { return s.value; }))\n      );\n    });\n  };\n  return zipSequence;\n}\n\n// #pragma Helper Functions\n\nfunction reify(iter, seq) {\n  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n}\n\nfunction validateEntry(entry) {\n  if (entry !== Object(entry)) {\n    throw new TypeError('Expected [K, V] tuple: ' + entry);\n  }\n}\n\nfunction collectionClass(collection) {\n  return isKeyed(collection)\n    ? KeyedCollection\n    : isIndexed(collection) ? IndexedCollection : SetCollection;\n}\n\nfunction makeSequence(collection) {\n  return Object.create(\n    (isKeyed(collection)\n      ? KeyedSeq\n      : isIndexed(collection) ? IndexedSeq : SetSeq).prototype\n  );\n}\n\nfunction cacheResultThrough() {\n  if (this._iter.cacheResult) {\n    this._iter.cacheResult();\n    this.size = this._iter.size;\n    return this;\n  }\n  return Seq.prototype.cacheResult.call(this);\n}\n\nfunction defaultComparator(a, b) {\n  if (a === undefined && b === undefined) {\n    return 0;\n  }\n\n  if (a === undefined) {\n    return 1;\n  }\n\n  if (b === undefined) {\n    return -1;\n  }\n\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\nfunction coerceKeyPath(keyPath) {\n  if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n    return keyPath;\n  }\n  if (isOrdered(keyPath)) {\n    return keyPath.toArray();\n  }\n  throw new TypeError(\n    'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath\n  );\n}\n\nfunction invariant(condition, error) {\n  if (!condition) { throw new Error(error); }\n}\n\nfunction assertNotInfinite(size) {\n  invariant(\n    size !== Infinity,\n    'Cannot perform this action with an infinite size.'\n  );\n}\n\n/**\n * Converts a value to a string, adding quotes if a string was provided.\n */\nfunction quoteString(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : String(value);\n}\n\nvar Map = (function (KeyedCollection$$1) {\n  function Map(value) {\n    return value === null || value === undefined\n      ? emptyMap()\n      : isMap(value) && !isOrdered(value)\n          ? value\n          : emptyMap().withMutations(function (map) {\n              var iter = KeyedCollection$$1(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v, k) { return map.set(k, v); });\n            });\n  }\n\n  if ( KeyedCollection$$1 ) Map.__proto__ = KeyedCollection$$1;\n  Map.prototype = Object.create( KeyedCollection$$1 && KeyedCollection$$1.prototype );\n  Map.prototype.constructor = Map;\n\n  Map.of = function of () {\n    var keyValues = [], len = arguments.length;\n    while ( len-- ) keyValues[ len ] = arguments[ len ];\n\n    return emptyMap().withMutations(function (map) {\n      for (var i = 0; i < keyValues.length; i += 2) {\n        if (i + 1 >= keyValues.length) {\n          throw new Error('Missing value for key: ' + keyValues[i]);\n        }\n        map.set(keyValues[i], keyValues[i + 1]);\n      }\n    });\n  };\n\n  Map.prototype.toString = function toString () {\n    return this.__toString('Map {', '}');\n  };\n\n  // @pragma Access\n\n  Map.prototype.get = function get (k, notSetValue) {\n    return this._root\n      ? this._root.get(0, undefined, k, notSetValue)\n      : notSetValue;\n  };\n\n  // @pragma Modification\n\n  Map.prototype.set = function set (k, v) {\n    return updateMap(this, k, v);\n  };\n\n  Map.prototype.setIn = function setIn (keyPath, v) {\n    return this.updateIn(keyPath, NOT_SET, function () { return v; });\n  };\n\n  Map.prototype.remove = function remove (k) {\n    return updateMap(this, k, NOT_SET);\n  };\n\n  Map.prototype.deleteIn = function deleteIn (keyPath) {\n    keyPath = [].concat( coerceKeyPath(keyPath) );\n    if (keyPath.length) {\n      var lastKey = keyPath.pop();\n      return this.updateIn(keyPath, function (c) { return c && c.remove(lastKey); });\n    }\n  };\n\n  Map.prototype.deleteAll = function deleteAll (keys) {\n    var collection = Collection(keys);\n\n    if (collection.size === 0) {\n      return this;\n    }\n\n    return this.withMutations(function (map) {\n      collection.forEach(function (key) { return map.remove(key); });\n    });\n  };\n\n  Map.prototype.update = function update (k, notSetValue, updater) {\n    return arguments.length === 1\n      ? k(this)\n      : this.updateIn([k], notSetValue, updater);\n  };\n\n  Map.prototype.updateIn = function updateIn (keyPath, notSetValue, updater) {\n    if (!updater) {\n      updater = notSetValue;\n      notSetValue = undefined;\n    }\n    var updatedValue = updateInDeepMap(\n      this,\n      coerceKeyPath(keyPath),\n      0,\n      notSetValue,\n      updater\n    );\n    return updatedValue === NOT_SET ? notSetValue : updatedValue;\n  };\n\n  Map.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._root = null;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyMap();\n  };\n\n  // @pragma Composition\n\n  Map.prototype.merge = function merge (/*...iters*/) {\n    return mergeIntoMapWith(this, undefined, arguments);\n  };\n\n  Map.prototype.mergeWith = function mergeWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoMapWith(this, merger, iters);\n  };\n\n  Map.prototype.mergeIn = function mergeIn (keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return this.updateIn(\n      keyPath,\n      emptyMap(),\n      function (m) { return typeof m.merge === 'function'\n          ? m.merge.apply(m, iters)\n          : iters[iters.length - 1]; }\n    );\n  };\n\n  Map.prototype.mergeDeep = function mergeDeep (/*...iters*/) {\n    return mergeIntoMapWith(this, deepMerger, arguments);\n  };\n\n  Map.prototype.mergeDeepWith = function mergeDeepWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n  };\n\n  Map.prototype.mergeDeepIn = function mergeDeepIn (keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return this.updateIn(\n      keyPath,\n      emptyMap(),\n      function (m) { return typeof m.mergeDeep === 'function'\n          ? m.mergeDeep.apply(m, iters)\n          : iters[iters.length - 1]; }\n    );\n  };\n\n  Map.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator));\n  };\n\n  Map.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator, mapper));\n  };\n\n  // @pragma Mutability\n\n  Map.prototype.withMutations = function withMutations (fn) {\n    var mutable = this.asMutable();\n    fn(mutable);\n    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n  };\n\n  Map.prototype.asMutable = function asMutable () {\n    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n  };\n\n  Map.prototype.asImmutable = function asImmutable () {\n    return this.__ensureOwner();\n  };\n\n  Map.prototype.wasAltered = function wasAltered () {\n    return this.__altered;\n  };\n\n  Map.prototype.__iterator = function __iterator (type, reverse) {\n    return new MapIterator(this, type, reverse);\n  };\n\n  Map.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    this._root &&\n      this._root.iterate(\n        function (entry) {\n          iterations++;\n          return fn(entry[1], entry[0], this$1);\n        },\n        reverse\n      );\n    return iterations;\n  };\n\n  Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyMap();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeMap(this.size, this._root, ownerID, this.__hash);\n  };\n\n  return Map;\n}(KeyedCollection));\n\nfunction isMap(maybeMap) {\n  return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n}\n\nMap.isMap = isMap;\n\nvar IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\nvar MapPrototype = Map.prototype;\nMapPrototype[IS_MAP_SENTINEL] = true;\nMapPrototype[DELETE] = MapPrototype.remove;\nMapPrototype.removeIn = MapPrototype.deleteIn;\nMapPrototype.removeAll = MapPrototype.deleteAll;\n\n// #pragma Trie Nodes\n\nvar ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n  this.ownerID = ownerID;\n  this.entries = entries;\n};\n\nArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && entries.length === 1) {\n    return; // undefined\n  }\n\n  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n    return createNodes(ownerID, entries, key, value);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new ArrayMapNode(ownerID, newEntries);\n};\n\nvar BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n  this.ownerID = ownerID;\n  this.bitmap = bitmap;\n  this.nodes = nodes;\n};\n\nBitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n  var bitmap = this.bitmap;\n  return (bitmap & bit) === 0\n    ? notSetValue\n    : this.nodes[popCount(bitmap & bit - 1)].get(\n        shift + SHIFT,\n        keyHash,\n        key,\n        notSetValue\n      );\n};\n\nBitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var bit = 1 << keyHashFrag;\n  var bitmap = this.bitmap;\n  var exists = (bitmap & bit) !== 0;\n\n  if (!exists && value === NOT_SET) {\n    return this;\n  }\n\n  var idx = popCount(bitmap & bit - 1);\n  var nodes = this.nodes;\n  var node = exists ? nodes[idx] : undefined;\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n\n  if (newNode === node) {\n    return this;\n  }\n\n  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n  }\n\n  if (\n    exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])\n  ) {\n    return nodes[idx ^ 1];\n  }\n\n  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n    return newNode;\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n  var newNodes = exists\n    ? newNode\n        ? setIn(nodes, idx, newNode, isEditable)\n        : spliceOut(nodes, idx, isEditable)\n    : spliceIn(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.bitmap = newBitmap;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n};\n\nvar HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n  this.ownerID = ownerID;\n  this.count = count;\n  this.nodes = nodes;\n};\n\nHashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var node = this.nodes[idx];\n  return node\n    ? node.get(shift + SHIFT, keyHash, key, notSetValue)\n    : notSetValue;\n};\n\nHashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var removed = value === NOT_SET;\n  var nodes = this.nodes;\n  var node = nodes[idx];\n\n  if (removed && !node) {\n    return this;\n  }\n\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n  if (newNode === node) {\n    return this;\n  }\n\n  var newCount = this.count;\n  if (!node) {\n    newCount++;\n  } else if (!newNode) {\n    newCount--;\n    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n      return packNodes(ownerID, nodes, newCount, idx);\n    }\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.count = newCount;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new HashArrayMapNode(ownerID, newCount, newNodes);\n};\n\nvar HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entries = entries;\n};\n\nHashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nHashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n\n  var removed = value === NOT_SET;\n\n  if (keyHash !== this.keyHash) {\n    if (removed) {\n      return this;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n  }\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && len === 2) {\n    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n};\n\nvar ValueNode = function ValueNode(ownerID, keyHash, entry) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entry = entry;\n};\n\nValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n};\n\nValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n  var keyMatch = is(key, this.entry[0]);\n  if (keyMatch ? value === this.entry[1] : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n\n  if (removed) {\n    SetRef(didChangeSize);\n    return; // undefined\n  }\n\n  if (keyMatch) {\n    if (ownerID && ownerID === this.ownerID) {\n      this.entry[1] = value;\n      return this;\n    }\n    return new ValueNode(ownerID, this.keyHash, [key, value]);\n  }\n\n  SetRef(didChangeSize);\n  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n};\n\n// #pragma Iterators\n\nArrayMapNode.prototype.iterate = (HashCollisionNode.prototype.iterate = function(\n  fn,\n  reverse\n) {\n  var entries = this.entries;\n  for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n    if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n      return false;\n    }\n  }\n});\n\nBitmapIndexedNode.prototype.iterate = (HashArrayMapNode.prototype.iterate = function(\n  fn,\n  reverse\n) {\n  var nodes = this.nodes;\n  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n    var node = nodes[reverse ? maxIndex - ii : ii];\n    if (node && node.iterate(fn, reverse) === false) {\n      return false;\n    }\n  }\n});\n\n// eslint-disable-next-line no-unused-vars\nValueNode.prototype.iterate = function(fn, reverse) {\n  return fn(this.entry);\n};\n\nvar MapIterator = (function (Iterator$$1) {\n  function MapIterator(map, type, reverse) {\n    this._type = type;\n    this._reverse = reverse;\n    this._stack = map._root && mapIteratorFrame(map._root);\n  }\n\n  if ( Iterator$$1 ) MapIterator.__proto__ = Iterator$$1;\n  MapIterator.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );\n  MapIterator.prototype.constructor = MapIterator;\n\n  MapIterator.prototype.next = function next () {\n    var this$1 = this;\n\n    var type = this._type;\n    var stack = this._stack;\n    while (stack) {\n      var node = stack.node;\n      var index = stack.index++;\n      var maxIndex = (void 0);\n      if (node.entry) {\n        if (index === 0) {\n          return mapIteratorValue(type, node.entry);\n        }\n      } else if (node.entries) {\n        maxIndex = node.entries.length - 1;\n        if (index <= maxIndex) {\n          return mapIteratorValue(\n            type,\n            node.entries[this$1._reverse ? maxIndex - index : index]\n          );\n        }\n      } else {\n        maxIndex = node.nodes.length - 1;\n        if (index <= maxIndex) {\n          var subNode = node.nodes[this$1._reverse ? maxIndex - index : index];\n          if (subNode) {\n            if (subNode.entry) {\n              return mapIteratorValue(type, subNode.entry);\n            }\n            stack = (this$1._stack = mapIteratorFrame(subNode, stack));\n          }\n          continue;\n        }\n      }\n      stack = (this$1._stack = this$1._stack.__prev);\n    }\n    return iteratorDone();\n  };\n\n  return MapIterator;\n}(Iterator));\n\nfunction mapIteratorValue(type, entry) {\n  return iteratorValue(type, entry[0], entry[1]);\n}\n\nfunction mapIteratorFrame(node, prev) {\n  return {\n    node: node,\n    index: 0,\n    __prev: prev\n  };\n}\n\nfunction makeMap(size, root, ownerID, hash$$1) {\n  var map = Object.create(MapPrototype);\n  map.size = size;\n  map._root = root;\n  map.__ownerID = ownerID;\n  map.__hash = hash$$1;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_MAP;\nfunction emptyMap() {\n  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n}\n\nfunction updateMap(map, k, v) {\n  var newRoot;\n  var newSize;\n  if (!map._root) {\n    if (v === NOT_SET) {\n      return map;\n    }\n    newSize = 1;\n    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n  } else {\n    var didChangeSize = MakeRef(CHANGE_LENGTH);\n    var didAlter = MakeRef(DID_ALTER);\n    newRoot = updateNode(\n      map._root,\n      map.__ownerID,\n      0,\n      undefined,\n      k,\n      v,\n      didChangeSize,\n      didAlter\n    );\n    if (!didAlter.value) {\n      return map;\n    }\n    newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n  }\n  if (map.__ownerID) {\n    map.size = newSize;\n    map._root = newRoot;\n    map.__hash = undefined;\n    map.__altered = true;\n    return map;\n  }\n  return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n}\n\nfunction updateNode(\n  node,\n  ownerID,\n  shift,\n  keyHash,\n  key,\n  value,\n  didChangeSize,\n  didAlter\n) {\n  if (!node) {\n    if (value === NOT_SET) {\n      return node;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return new ValueNode(ownerID, keyHash, [key, value]);\n  }\n  return node.update(\n    ownerID,\n    shift,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n}\n\nfunction isLeafNode(node) {\n  return node.constructor === ValueNode ||\n    node.constructor === HashCollisionNode;\n}\n\nfunction mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n  if (node.keyHash === keyHash) {\n    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n  }\n\n  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n  var newNode;\n  var nodes = idx1 === idx2\n    ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n    : ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2\n        ? [node, newNode]\n        : [newNode, node]);\n\n  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);\n}\n\nfunction createNodes(ownerID, entries, key, value) {\n  if (!ownerID) {\n    ownerID = new OwnerID();\n  }\n  var node = new ValueNode(ownerID, hash(key), [key, value]);\n  for (var ii = 0; ii < entries.length; ii++) {\n    var entry = entries[ii];\n    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n  }\n  return node;\n}\n\nfunction packNodes(ownerID, nodes, count, excluding) {\n  var bitmap = 0;\n  var packedII = 0;\n  var packedNodes = new Array(count);\n  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, (bit <<= 1)) {\n    var node = nodes[ii];\n    if (node !== undefined && ii !== excluding) {\n      bitmap |= bit;\n      packedNodes[packedII++] = node;\n    }\n  }\n  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n}\n\nfunction expandNodes(ownerID, nodes, bitmap, including, node) {\n  var count = 0;\n  var expandedNodes = new Array(SIZE);\n  for (var ii = 0; bitmap !== 0; ii++, (bitmap >>>= 1)) {\n    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n  }\n  expandedNodes[including] = node;\n  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n}\n\nfunction mergeIntoMapWith(map, merger, collections) {\n  var iters = [];\n  for (var ii = 0; ii < collections.length; ii++) {\n    var value = collections[ii];\n    var iter = KeyedCollection(value);\n    if (!isCollection(value)) {\n      iter = iter.map(function (v) { return fromJS(v); });\n    }\n    iters.push(iter);\n  }\n  return mergeIntoCollectionWith(map, merger, iters);\n}\n\nfunction deepMerger(oldVal, newVal) {\n  return oldVal && oldVal.mergeDeep && isCollection(newVal)\n    ? oldVal.mergeDeep(newVal)\n    : is(oldVal, newVal) ? oldVal : newVal;\n}\n\nfunction deepMergerWith(merger) {\n  return function (oldVal, newVal, key) {\n    if (oldVal && oldVal.mergeDeepWith && isCollection(newVal)) {\n      return oldVal.mergeDeepWith(merger, newVal);\n    }\n    var nextValue = merger(oldVal, newVal, key);\n    return is(oldVal, nextValue) ? oldVal : nextValue;\n  };\n}\n\nfunction mergeIntoCollectionWith(collection, merger, iters) {\n  iters = iters.filter(function (x) { return x.size !== 0; });\n  if (iters.length === 0) {\n    return collection;\n  }\n  if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n    return collection.constructor(iters[0]);\n  }\n  return collection.withMutations(function (collection) {\n    var mergeIntoMap = merger\n      ? function (value, key) {\n          collection.update(\n            key,\n            NOT_SET,\n            function (oldVal) { return oldVal === NOT_SET ? value : merger(oldVal, value, key); }\n          );\n        }\n      : function (value, key) {\n          collection.set(key, value);\n        };\n    for (var ii = 0; ii < iters.length; ii++) {\n      iters[ii].forEach(mergeIntoMap);\n    }\n  });\n}\n\nfunction updateInDeepMap(existing, keyPath, i, notSetValue, updater) {\n  var isNotSet = existing === NOT_SET;\n  if (i === keyPath.length) {\n    var existingValue = isNotSet ? notSetValue : existing;\n    var newValue = updater(existingValue);\n    return newValue === existingValue ? existing : newValue;\n  }\n  if (!(isNotSet || (existing && existing.set))) {\n    throw new TypeError(\n      'Invalid keyPath: Value at [' +\n        keyPath.slice(0, i).map(quoteString) +\n        '] does not have a .set() method and cannot be updated: ' +\n        existing\n    );\n  }\n  var key = keyPath[i];\n  var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n  var nextUpdated = updateInDeepMap(\n    nextExisting,\n    keyPath,\n    i + 1,\n    notSetValue,\n    updater\n  );\n  return nextUpdated === nextExisting\n    ? existing\n    : nextUpdated === NOT_SET\n        ? existing.remove(key)\n        : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n}\n\nfunction popCount(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n\nfunction setIn(array, idx, val, canEdit) {\n  var newArray = canEdit ? array : arrCopy(array);\n  newArray[idx] = val;\n  return newArray;\n}\n\nfunction spliceIn(array, idx, val, canEdit) {\n  var newLen = array.length + 1;\n  if (canEdit && idx + 1 === newLen) {\n    array[idx] = val;\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      newArray[ii] = val;\n      after = -1;\n    } else {\n      newArray[ii] = array[ii + after];\n    }\n  }\n  return newArray;\n}\n\nfunction spliceOut(array, idx, canEdit) {\n  var newLen = array.length - 1;\n  if (canEdit && idx === newLen) {\n    array.pop();\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      after = 1;\n    }\n    newArray[ii] = array[ii + after];\n  }\n  return newArray;\n}\n\nvar MAX_ARRAY_MAP_SIZE = SIZE / 4;\nvar MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\nvar MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\nvar List = (function (IndexedCollection$$1) {\n  function List(value) {\n    var empty = emptyList();\n    if (value === null || value === undefined) {\n      return empty;\n    }\n    if (isList(value)) {\n      return value;\n    }\n    var iter = IndexedCollection$$1(value);\n    var size = iter.size;\n    if (size === 0) {\n      return empty;\n    }\n    assertNotInfinite(size);\n    if (size > 0 && size < SIZE) {\n      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n    }\n    return empty.withMutations(function (list) {\n      list.setSize(size);\n      iter.forEach(function (v, i) { return list.set(i, v); });\n    });\n  }\n\n  if ( IndexedCollection$$1 ) List.__proto__ = IndexedCollection$$1;\n  List.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );\n  List.prototype.constructor = List;\n\n  List.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  List.prototype.toString = function toString () {\n    return this.__toString('List [', ']');\n  };\n\n  // @pragma Access\n\n  List.prototype.get = function get (index, notSetValue) {\n    index = wrapIndex(this, index);\n    if (index >= 0 && index < this.size) {\n      index += this._origin;\n      var node = listNodeFor(this, index);\n      return node && node.array[index & MASK];\n    }\n    return notSetValue;\n  };\n\n  // @pragma Modification\n\n  List.prototype.set = function set (index, value) {\n    return updateList(this, index, value);\n  };\n\n  List.prototype.remove = function remove (index) {\n    return !this.has(index)\n      ? this\n      : index === 0\n          ? this.shift()\n          : index === this.size - 1 ? this.pop() : this.splice(index, 1);\n  };\n\n  List.prototype.insert = function insert (index, value) {\n    return this.splice(index, 0, value);\n  };\n\n  List.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = (this._origin = (this._capacity = 0));\n      this._level = SHIFT;\n      this._root = (this._tail = null);\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyList();\n  };\n\n  List.prototype.push = function push (/*...values*/) {\n    var values = arguments;\n    var oldSize = this.size;\n    return this.withMutations(function (list) {\n      setListBounds(list, 0, oldSize + values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(oldSize + ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.pop = function pop () {\n    return setListBounds(this, 0, -1);\n  };\n\n  List.prototype.unshift = function unshift (/*...values*/) {\n    var values = arguments;\n    return this.withMutations(function (list) {\n      setListBounds(list, -values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.shift = function shift () {\n    return setListBounds(this, 1);\n  };\n\n  // @pragma Composition\n\n  List.prototype.merge = function merge (/*...iters*/) {\n    return mergeIntoListWith(this, undefined, arguments);\n  };\n\n  List.prototype.mergeWith = function mergeWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoListWith(this, merger, iters);\n  };\n\n  List.prototype.mergeDeep = function mergeDeep (/*...iters*/) {\n    return mergeIntoListWith(this, deepMerger, arguments);\n  };\n\n  List.prototype.mergeDeepWith = function mergeDeepWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoListWith(this, deepMergerWith(merger), iters);\n  };\n\n  List.prototype.setSize = function setSize (size) {\n    return setListBounds(this, 0, size);\n  };\n\n  // @pragma Iteration\n\n  List.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    if (wholeSlice(begin, end, size)) {\n      return this;\n    }\n    return setListBounds(\n      this,\n      resolveBegin(begin, size),\n      resolveEnd(end, size)\n    );\n  };\n\n  List.prototype.__iterator = function __iterator (type, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    return new Iterator(function () {\n      var value = values();\n      return value === DONE\n        ? iteratorDone()\n        : iteratorValue(type, reverse ? --index : index++, value);\n    });\n  };\n\n  List.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    var value;\n    while ((value = values()) !== DONE) {\n      if (fn(value, reverse ? --index : index++, this$1) === false) {\n        break;\n      }\n    }\n    return index;\n  };\n\n  List.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyList();\n      }\n      this.__ownerID = ownerID;\n      return this;\n    }\n    return makeList(\n      this._origin,\n      this._capacity,\n      this._level,\n      this._root,\n      this._tail,\n      ownerID,\n      this.__hash\n    );\n  };\n\n  return List;\n}(IndexedCollection));\n\nfunction isList(maybeList) {\n  return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n}\n\nList.isList = isList;\n\nvar IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\nvar ListPrototype = List.prototype;\nListPrototype[IS_LIST_SENTINEL] = true;\nListPrototype[DELETE] = ListPrototype.remove;\nListPrototype.setIn = MapPrototype.setIn;\nListPrototype.deleteIn = (ListPrototype.removeIn = MapPrototype.removeIn);\nListPrototype.update = MapPrototype.update;\nListPrototype.updateIn = MapPrototype.updateIn;\nListPrototype.mergeIn = MapPrototype.mergeIn;\nListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\nListPrototype.withMutations = MapPrototype.withMutations;\nListPrototype.asMutable = MapPrototype.asMutable;\nListPrototype.asImmutable = MapPrototype.asImmutable;\nListPrototype.wasAltered = MapPrototype.wasAltered;\n\nvar VNode = function VNode(array, ownerID) {\n  this.array = array;\n  this.ownerID = ownerID;\n};\n\n// TODO: seems like these methods are very similar\n\nVNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {\n  if (index === level ? 1 << level : 0 || this.array.length === 0) {\n    return this;\n  }\n  var originIndex = index >>> level & MASK;\n  if (originIndex >= this.array.length) {\n    return new VNode([], ownerID);\n  }\n  var removingFirst = originIndex === 0;\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[originIndex];\n    newChild = oldChild &&\n      oldChild.removeBefore(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && removingFirst) {\n      return this;\n    }\n  }\n  if (removingFirst && !newChild) {\n    return this;\n  }\n  var editable = editableVNode(this, ownerID);\n  if (!removingFirst) {\n    for (var ii = 0; ii < originIndex; ii++) {\n      editable.array[ii] = undefined;\n    }\n  }\n  if (newChild) {\n    editable.array[originIndex] = newChild;\n  }\n  return editable;\n};\n\nVNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {\n  if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n    return this;\n  }\n  var sizeIndex = index - 1 >>> level & MASK;\n  if (sizeIndex >= this.array.length) {\n    return this;\n  }\n\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[sizeIndex];\n    newChild = oldChild &&\n      oldChild.removeAfter(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n      return this;\n    }\n  }\n\n  var editable = editableVNode(this, ownerID);\n  editable.array.splice(sizeIndex + 1);\n  if (newChild) {\n    editable.array[sizeIndex] = newChild;\n  }\n  return editable;\n};\n\nvar DONE = {};\n\nfunction iterateList(list, reverse) {\n  var left = list._origin;\n  var right = list._capacity;\n  var tailPos = getTailOffset(right);\n  var tail = list._tail;\n\n  return iterateNodeOrLeaf(list._root, list._level, 0);\n\n  function iterateNodeOrLeaf(node, level, offset) {\n    return level === 0\n      ? iterateLeaf(node, offset)\n      : iterateNode(node, level, offset);\n  }\n\n  function iterateLeaf(node, offset) {\n    var array = offset === tailPos ? tail && tail.array : node && node.array;\n    var from = offset > left ? 0 : left - offset;\n    var to = right - offset;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      if (from === to) {\n        return DONE;\n      }\n      var idx = reverse ? --to : from++;\n      return array && array[idx];\n    };\n  }\n\n  function iterateNode(node, level, offset) {\n    var values;\n    var array = node && node.array;\n    var from = offset > left ? 0 : left - offset >> level;\n    var to = (right - offset >> level) + 1;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      while (true) {\n        if (values) {\n          var value = values();\n          if (value !== DONE) {\n            return value;\n          }\n          values = null;\n        }\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        values = iterateNodeOrLeaf(\n          array && array[idx],\n          level - SHIFT,\n          offset + (idx << level)\n        );\n      }\n    };\n  }\n}\n\nfunction makeList(origin, capacity, level, root, tail, ownerID, hash) {\n  var list = Object.create(ListPrototype);\n  list.size = capacity - origin;\n  list._origin = origin;\n  list._capacity = capacity;\n  list._level = level;\n  list._root = root;\n  list._tail = tail;\n  list.__ownerID = ownerID;\n  list.__hash = hash;\n  list.__altered = false;\n  return list;\n}\n\nvar EMPTY_LIST;\nfunction emptyList() {\n  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n}\n\nfunction updateList(list, index, value) {\n  index = wrapIndex(list, index);\n\n  if (index !== index) {\n    return list;\n  }\n\n  if (index >= list.size || index < 0) {\n    return list.withMutations(function (list) {\n      index < 0\n        ? setListBounds(list, index).set(0, value)\n        : setListBounds(list, 0, index + 1).set(index, value);\n    });\n  }\n\n  index += list._origin;\n\n  var newTail = list._tail;\n  var newRoot = list._root;\n  var didAlter = MakeRef(DID_ALTER);\n  if (index >= getTailOffset(list._capacity)) {\n    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n  } else {\n    newRoot = updateVNode(\n      newRoot,\n      list.__ownerID,\n      list._level,\n      index,\n      value,\n      didAlter\n    );\n  }\n\n  if (!didAlter.value) {\n    return list;\n  }\n\n  if (list.__ownerID) {\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\n\nfunction updateVNode(node, ownerID, level, index, value, didAlter) {\n  var idx = index >>> level & MASK;\n  var nodeHas = node && idx < node.array.length;\n  if (!nodeHas && value === undefined) {\n    return node;\n  }\n\n  var newNode;\n\n  if (level > 0) {\n    var lowerNode = node && node.array[idx];\n    var newLowerNode = updateVNode(\n      lowerNode,\n      ownerID,\n      level - SHIFT,\n      index,\n      value,\n      didAlter\n    );\n    if (newLowerNode === lowerNode) {\n      return node;\n    }\n    newNode = editableVNode(node, ownerID);\n    newNode.array[idx] = newLowerNode;\n    return newNode;\n  }\n\n  if (nodeHas && node.array[idx] === value) {\n    return node;\n  }\n\n  SetRef(didAlter);\n\n  newNode = editableVNode(node, ownerID);\n  if (value === undefined && idx === newNode.array.length - 1) {\n    newNode.array.pop();\n  } else {\n    newNode.array[idx] = value;\n  }\n  return newNode;\n}\n\nfunction editableVNode(node, ownerID) {\n  if (ownerID && node && ownerID === node.ownerID) {\n    return node;\n  }\n  return new VNode(node ? node.array.slice() : [], ownerID);\n}\n\nfunction listNodeFor(list, rawIndex) {\n  if (rawIndex >= getTailOffset(list._capacity)) {\n    return list._tail;\n  }\n  if (rawIndex < 1 << list._level + SHIFT) {\n    var node = list._root;\n    var level = list._level;\n    while (node && level > 0) {\n      node = node.array[rawIndex >>> level & MASK];\n      level -= SHIFT;\n    }\n    return node;\n  }\n}\n\nfunction setListBounds(list, begin, end) {\n  // Sanitize begin & end using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  if (begin !== undefined) {\n    begin |= 0;\n  }\n  if (end !== undefined) {\n    end |= 0;\n  }\n  var owner = list.__ownerID || new OwnerID();\n  var oldOrigin = list._origin;\n  var oldCapacity = list._capacity;\n  var newOrigin = oldOrigin + begin;\n  var newCapacity = end === undefined\n    ? oldCapacity\n    : end < 0 ? oldCapacity + end : oldOrigin + end;\n  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n    return list;\n  }\n\n  // If it's going to end after it starts, it's empty.\n  if (newOrigin >= newCapacity) {\n    return list.clear();\n  }\n\n  var newLevel = list._level;\n  var newRoot = list._root;\n\n  // New origin might need creating a higher root.\n  var offsetShift = 0;\n  while (newOrigin + offsetShift < 0) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [undefined, newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n    offsetShift += 1 << newLevel;\n  }\n  if (offsetShift) {\n    newOrigin += offsetShift;\n    oldOrigin += offsetShift;\n    newCapacity += offsetShift;\n    oldCapacity += offsetShift;\n  }\n\n  var oldTailOffset = getTailOffset(oldCapacity);\n  var newTailOffset = getTailOffset(newCapacity);\n\n  // New size might need creating a higher root.\n  while (newTailOffset >= 1 << newLevel + SHIFT) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n  }\n\n  // Locate or create the new tail.\n  var oldTail = list._tail;\n  var newTail = newTailOffset < oldTailOffset\n    ? listNodeFor(list, newCapacity - 1)\n    : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n  // Merge Tail into tree.\n  if (\n    oldTail &&\n    newTailOffset > oldTailOffset &&\n    newOrigin < oldCapacity &&\n    oldTail.array.length\n  ) {\n    newRoot = editableVNode(newRoot, owner);\n    var node = newRoot;\n    for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n      var idx = oldTailOffset >>> level & MASK;\n      node = (node.array[idx] = editableVNode(node.array[idx], owner));\n    }\n    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;\n  }\n\n  // If the size has been reduced, there's a chance the tail needs to be trimmed.\n  if (newCapacity < oldCapacity) {\n    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n  }\n\n  // If the new origin is within the tail, then we do not need a root.\n  if (newOrigin >= newTailOffset) {\n    newOrigin -= newTailOffset;\n    newCapacity -= newTailOffset;\n    newLevel = SHIFT;\n    newRoot = null;\n    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n    offsetShift = 0;\n\n    // Identify the new top root node of the subtree of the old root.\n    while (newRoot) {\n      var beginIndex = newOrigin >>> newLevel & MASK;\n      if (beginIndex !== newTailOffset >>> newLevel & MASK) {\n        break;\n      }\n      if (beginIndex) {\n        offsetShift += (1 << newLevel) * beginIndex;\n      }\n      newLevel -= SHIFT;\n      newRoot = newRoot.array[beginIndex];\n    }\n\n    // Trim the new sides of the new root.\n    if (newRoot && newOrigin > oldOrigin) {\n      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n    }\n    if (newRoot && newTailOffset < oldTailOffset) {\n      newRoot = newRoot.removeAfter(\n        owner,\n        newLevel,\n        newTailOffset - offsetShift\n      );\n    }\n    if (offsetShift) {\n      newOrigin -= offsetShift;\n      newCapacity -= offsetShift;\n    }\n  }\n\n  if (list.__ownerID) {\n    list.size = newCapacity - newOrigin;\n    list._origin = newOrigin;\n    list._capacity = newCapacity;\n    list._level = newLevel;\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n}\n\nfunction mergeIntoListWith(list, merger, collections) {\n  var iters = [];\n  var maxSize = 0;\n  for (var ii = 0; ii < collections.length; ii++) {\n    var value = collections[ii];\n    var iter = IndexedCollection(value);\n    if (iter.size > maxSize) {\n      maxSize = iter.size;\n    }\n    if (!isCollection(value)) {\n      iter = iter.map(function (v) { return fromJS(v); });\n    }\n    iters.push(iter);\n  }\n  if (maxSize > list.size) {\n    list = list.setSize(maxSize);\n  }\n  return mergeIntoCollectionWith(list, merger, iters);\n}\n\nfunction getTailOffset(size) {\n  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;\n}\n\nvar OrderedMap = (function (Map$$1) {\n  function OrderedMap(value) {\n    return value === null || value === undefined\n      ? emptyOrderedMap()\n      : isOrderedMap(value)\n          ? value\n          : emptyOrderedMap().withMutations(function (map) {\n              var iter = KeyedCollection(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v, k) { return map.set(k, v); });\n            });\n  }\n\n  if ( Map$$1 ) OrderedMap.__proto__ = Map$$1;\n  OrderedMap.prototype = Object.create( Map$$1 && Map$$1.prototype );\n  OrderedMap.prototype.constructor = OrderedMap;\n\n  OrderedMap.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedMap.prototype.toString = function toString () {\n    return this.__toString('OrderedMap {', '}');\n  };\n\n  // @pragma Access\n\n  OrderedMap.prototype.get = function get (k, notSetValue) {\n    var index = this._map.get(k);\n    return index !== undefined ? this._list.get(index)[1] : notSetValue;\n  };\n\n  // @pragma Modification\n\n  OrderedMap.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._map.clear();\n      this._list.clear();\n      return this;\n    }\n    return emptyOrderedMap();\n  };\n\n  OrderedMap.prototype.set = function set (k, v) {\n    return updateOrderedMap(this, k, v);\n  };\n\n  OrderedMap.prototype.remove = function remove (k) {\n    return updateOrderedMap(this, k, NOT_SET);\n  };\n\n  OrderedMap.prototype.wasAltered = function wasAltered () {\n    return this._map.wasAltered() || this._list.wasAltered();\n  };\n\n  OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._list.__iterate(\n      function (entry) { return entry && fn(entry[1], entry[0], this$1); },\n      reverse\n    );\n  };\n\n  OrderedMap.prototype.__iterator = function __iterator (type, reverse) {\n    return this._list.fromEntrySeq().__iterator(type, reverse);\n  };\n\n  OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    var newList = this._list.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyOrderedMap();\n      }\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      this._list = newList;\n      return this;\n    }\n    return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n  };\n\n  return OrderedMap;\n}(Map));\n\nfunction isOrderedMap(maybeOrderedMap) {\n  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n}\n\nOrderedMap.isOrderedMap = isOrderedMap;\n\nOrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\nOrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\nfunction makeOrderedMap(map, list, ownerID, hash) {\n  var omap = Object.create(OrderedMap.prototype);\n  omap.size = map ? map.size : 0;\n  omap._map = map;\n  omap._list = list;\n  omap.__ownerID = ownerID;\n  omap.__hash = hash;\n  return omap;\n}\n\nvar EMPTY_ORDERED_MAP;\nfunction emptyOrderedMap() {\n  return EMPTY_ORDERED_MAP ||\n    (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n}\n\nfunction updateOrderedMap(omap, k, v) {\n  var map = omap._map;\n  var list = omap._list;\n  var i = map.get(k);\n  var has = i !== undefined;\n  var newMap;\n  var newList;\n  if (v === NOT_SET) {\n    // removed\n    if (!has) {\n      return omap;\n    }\n    if (list.size >= SIZE && list.size >= map.size * 2) {\n      newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });\n      newMap = newList.toKeyedSeq().map(function (entry) { return entry[0]; }).flip().toMap();\n      if (omap.__ownerID) {\n        newMap.__ownerID = (newList.__ownerID = omap.__ownerID);\n      }\n    } else {\n      newMap = map.remove(k);\n      newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n    }\n  } else if (has) {\n    if (v === list.get(i)[1]) {\n      return omap;\n    }\n    newMap = map;\n    newList = list.set(i, [k, v]);\n  } else {\n    newMap = map.set(k, list.size);\n    newList = list.set(list.size, [k, v]);\n  }\n  if (omap.__ownerID) {\n    omap.size = newMap.size;\n    omap._map = newMap;\n    omap._list = newList;\n    omap.__hash = undefined;\n    return omap;\n  }\n  return makeOrderedMap(newMap, newList);\n}\n\nvar Stack = (function (IndexedCollection$$1) {\n  function Stack(value) {\n    return value === null || value === undefined\n      ? emptyStack()\n      : isStack(value) ? value : emptyStack().pushAll(value);\n  }\n\n  if ( IndexedCollection$$1 ) Stack.__proto__ = IndexedCollection$$1;\n  Stack.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );\n  Stack.prototype.constructor = Stack;\n\n  Stack.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Stack.prototype.toString = function toString () {\n    return this.__toString('Stack [', ']');\n  };\n\n  // @pragma Access\n\n  Stack.prototype.get = function get (index, notSetValue) {\n    var head = this._head;\n    index = wrapIndex(this, index);\n    while (head && index--) {\n      head = head.next;\n    }\n    return head ? head.value : notSetValue;\n  };\n\n  Stack.prototype.peek = function peek () {\n    return this._head && this._head.value;\n  };\n\n  // @pragma Modification\n\n  Stack.prototype.push = function push (/*...values*/) {\n    var arguments$1 = arguments;\n\n    if (arguments.length === 0) {\n      return this;\n    }\n    var newSize = this.size + arguments.length;\n    var head = this._head;\n    for (var ii = arguments.length - 1; ii >= 0; ii--) {\n      head = {\n        value: arguments$1[ii],\n        next: head\n      };\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pushAll = function pushAll (iter) {\n    iter = IndexedCollection$$1(iter);\n    if (iter.size === 0) {\n      return this;\n    }\n    if (this.size === 0 && isStack(iter)) {\n      return iter;\n    }\n    assertNotInfinite(iter.size);\n    var newSize = this.size;\n    var head = this._head;\n    iter.__iterate(\n      function (value) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      },\n      /* reverse */ true\n    );\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pop = function pop () {\n    return this.slice(1);\n  };\n\n  Stack.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._head = undefined;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyStack();\n  };\n\n  Stack.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    var resolvedBegin = resolveBegin(begin, this.size);\n    var resolvedEnd = resolveEnd(end, this.size);\n    if (resolvedEnd !== this.size) {\n      // super.slice(begin, end);\n      return IndexedCollection$$1.prototype.slice.call(this, begin, end);\n    }\n    var newSize = this.size - resolvedBegin;\n    var head = this._head;\n    while (resolvedBegin--) {\n      head = head.next;\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  // @pragma Mutability\n\n  Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyStack();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeStack(this.size, this._head, ownerID, this.__hash);\n  };\n\n  // @pragma Iteration\n\n  Stack.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterate(\n        function (v, k) { return fn(v, k, this$1); },\n        reverse\n      );\n    }\n    var iterations = 0;\n    var node = this._head;\n    while (node) {\n      if (fn(node.value, iterations++, this$1) === false) {\n        break;\n      }\n      node = node.next;\n    }\n    return iterations;\n  };\n\n  Stack.prototype.__iterator = function __iterator (type, reverse) {\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterator(type, reverse);\n    }\n    var iterations = 0;\n    var node = this._head;\n    return new Iterator(function () {\n      if (node) {\n        var value = node.value;\n        node = node.next;\n        return iteratorValue(type, iterations++, value);\n      }\n      return iteratorDone();\n    });\n  };\n\n  return Stack;\n}(IndexedCollection));\n\nfunction isStack(maybeStack) {\n  return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n}\n\nStack.isStack = isStack;\n\nvar IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\nvar StackPrototype = Stack.prototype;\nStackPrototype[IS_STACK_SENTINEL] = true;\nStackPrototype.withMutations = MapPrototype.withMutations;\nStackPrototype.asMutable = MapPrototype.asMutable;\nStackPrototype.asImmutable = MapPrototype.asImmutable;\nStackPrototype.wasAltered = MapPrototype.wasAltered;\nStackPrototype.shift = StackPrototype.pop;\nStackPrototype.unshift = StackPrototype.push;\nStackPrototype.unshiftAll = StackPrototype.pushAll;\n\nfunction makeStack(size, head, ownerID, hash) {\n  var map = Object.create(StackPrototype);\n  map.size = size;\n  map._head = head;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_STACK;\nfunction emptyStack() {\n  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n}\n\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (\n    !isCollection(b) ||\n    (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||\n    (a.__hash !== undefined &&\n      b.__hash !== undefined &&\n      a.__hash !== b.__hash) ||\n    isKeyed(a) !== isKeyed(b) ||\n    isIndexed(a) !== isIndexed(b) ||\n    isOrdered(a) !== isOrdered(b)\n  ) {\n    return false;\n  }\n\n  if (a.size === 0 && b.size === 0) {\n    return true;\n  }\n\n  var notAssociative = !isAssociative(a);\n\n  if (isOrdered(a)) {\n    var entries = a.entries();\n    return b.every(function (v, k) {\n      var entry = entries.next().value;\n      return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n    }) && entries.next().done;\n  }\n\n  var flipped = false;\n\n  if (a.size === undefined) {\n    if (b.size === undefined) {\n      if (typeof a.cacheResult === 'function') {\n        a.cacheResult();\n      }\n    } else {\n      flipped = true;\n      var _ = a;\n      a = b;\n      b = _;\n    }\n  }\n\n  var allEqual = true;\n  var bSize = b.__iterate(function (v, k) {\n    if (\n      notAssociative\n        ? !a.has(v)\n        : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)\n    ) {\n      allEqual = false;\n      return false;\n    }\n  });\n\n  return allEqual && a.size === bSize;\n}\n\n/**\n * Contributes additional methods to a constructor\n */\nfunction mixin(ctor, methods) {\n  var keyCopier = function (key) {\n    ctor.prototype[key] = methods[key];\n  };\n  Object.keys(methods).forEach(keyCopier);\n  Object.getOwnPropertySymbols &&\n    Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n  return ctor;\n}\n\nvar Set = (function (SetCollection$$1) {\n  function Set(value) {\n    return value === null || value === undefined\n      ? emptySet()\n      : isSet(value) && !isOrdered(value)\n          ? value\n          : emptySet().withMutations(function (set) {\n              var iter = SetCollection$$1(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v) { return set.add(v); });\n            });\n  }\n\n  if ( SetCollection$$1 ) Set.__proto__ = SetCollection$$1;\n  Set.prototype = Object.create( SetCollection$$1 && SetCollection$$1.prototype );\n  Set.prototype.constructor = Set;\n\n  Set.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Set.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  Set.intersect = function intersect (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.intersect.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.union = function union (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.union.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.prototype.toString = function toString () {\n    return this.__toString('Set {', '}');\n  };\n\n  // @pragma Access\n\n  Set.prototype.has = function has (value) {\n    return this._map.has(value);\n  };\n\n  // @pragma Modification\n\n  Set.prototype.add = function add (value) {\n    return updateSet(this, this._map.set(value, true));\n  };\n\n  Set.prototype.remove = function remove (value) {\n    return updateSet(this, this._map.remove(value));\n  };\n\n  Set.prototype.clear = function clear () {\n    return updateSet(this, this._map.clear());\n  };\n\n  // @pragma Composition\n\n  Set.prototype.union = function union () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    iters = iters.filter(function (x) { return x.size !== 0; });\n    if (iters.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n      return this.constructor(iters[0]);\n    }\n    return this.withMutations(function (set) {\n      for (var ii = 0; ii < iters.length; ii++) {\n        SetCollection$$1(iters[ii]).forEach(function (value) { return set.add(value); });\n      }\n    });\n  };\n\n  Set.prototype.intersect = function intersect () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    iters = iters.map(function (iter) { return SetCollection$$1(iter); });\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (!iters.every(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.subtract = function subtract () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (iters.some(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.merge = function merge () {\n    return this.union.apply(this, arguments);\n  };\n\n  Set.prototype.mergeWith = function mergeWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return this.union.apply(this, iters);\n  };\n\n  Set.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator));\n  };\n\n  Set.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator, mapper));\n  };\n\n  Set.prototype.wasAltered = function wasAltered () {\n    return this._map.wasAltered();\n  };\n\n  Set.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._map.__iterate(function (_, k) { return fn(k, k, this$1); }, reverse);\n  };\n\n  Set.prototype.__iterator = function __iterator (type, reverse) {\n    return this._map.map(function (_, k) { return k; }).__iterator(type, reverse);\n  };\n\n  Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptySet();\n      }\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      return this;\n    }\n    return this.__make(newMap, ownerID);\n  };\n\n  return Set;\n}(SetCollection));\n\nfunction isSet(maybeSet) {\n  return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n}\n\nSet.isSet = isSet;\n\nvar IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\nvar SetPrototype = Set.prototype;\nSetPrototype[IS_SET_SENTINEL] = true;\nSetPrototype[DELETE] = SetPrototype.remove;\nSetPrototype.mergeDeep = SetPrototype.merge;\nSetPrototype.mergeDeepWith = SetPrototype.mergeWith;\nSetPrototype.withMutations = MapPrototype.withMutations;\nSetPrototype.asMutable = MapPrototype.asMutable;\nSetPrototype.asImmutable = MapPrototype.asImmutable;\n\nSetPrototype.__empty = emptySet;\nSetPrototype.__make = makeSet;\n\nfunction updateSet(set, newMap) {\n  if (set.__ownerID) {\n    set.size = newMap.size;\n    set._map = newMap;\n    return set;\n  }\n  return newMap === set._map\n    ? set\n    : newMap.size === 0 ? set.__empty() : set.__make(newMap);\n}\n\nfunction makeSet(map, ownerID) {\n  var set = Object.create(SetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_SET;\nfunction emptySet() {\n  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n}\n\n/**\n * Returns a lazy seq of nums from start (inclusive) to end\n * (exclusive), by step, where start defaults to 0, step to 1, and end to\n * infinity. When start is equal to end, returns empty list.\n */\nvar Range = (function (IndexedSeq$$1) {\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      return new Range(start, end, step);\n    }\n    invariant(step !== 0, 'Cannot step a Range by 0');\n    start = start || 0;\n    if (end === undefined) {\n      end = Infinity;\n    }\n    step = step === undefined ? 1 : Math.abs(step);\n    if (end < start) {\n      step = -step;\n    }\n    this._start = start;\n    this._end = end;\n    this._step = step;\n    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n    if (this.size === 0) {\n      if (EMPTY_RANGE) {\n        return EMPTY_RANGE;\n      }\n      EMPTY_RANGE = this;\n    }\n  }\n\n  if ( IndexedSeq$$1 ) Range.__proto__ = IndexedSeq$$1;\n  Range.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  Range.prototype.constructor = Range;\n\n  Range.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Range []';\n    }\n    return 'Range [ ' +\n      this._start +\n      '...' +\n      this._end +\n      (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n  };\n\n  Range.prototype.get = function get (index, notSetValue) {\n    return this.has(index)\n      ? this._start + wrapIndex(this, index) * this._step\n      : notSetValue;\n  };\n\n  Range.prototype.includes = function includes (searchValue) {\n    var possibleIndex = (searchValue - this._start) / this._step;\n    return possibleIndex >= 0 &&\n      possibleIndex < this.size &&\n      possibleIndex === Math.floor(possibleIndex);\n  };\n\n  Range.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    begin = resolveBegin(begin, this.size);\n    end = resolveEnd(end, this.size);\n    if (end <= begin) {\n      return new Range(0, 0);\n    }\n    return new Range(\n      this.get(begin, this._end),\n      this.get(end, this._end),\n      this._step\n    );\n  };\n\n  Range.prototype.indexOf = function indexOf (searchValue) {\n    var offsetValue = searchValue - this._start;\n    if (offsetValue % this._step === 0) {\n      var index = offsetValue / this._step;\n      if (index >= 0 && index < this.size) {\n        return index;\n      }\n    }\n    return -1;\n  };\n\n  Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    return this.indexOf(searchValue);\n  };\n\n  Range.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    while (i !== size) {\n      if (fn(value, reverse ? size - ++i : i++, this$1) === false) {\n        break;\n      }\n      value += reverse ? -step : step;\n    }\n    return i;\n  };\n\n  Range.prototype.__iterator = function __iterator (type, reverse) {\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var v = value;\n      value += reverse ? -step : step;\n      return iteratorValue(type, reverse ? size - ++i : i++, v);\n    });\n  };\n\n  Range.prototype.equals = function equals (other) {\n    return other instanceof Range\n      ? this._start === other._start &&\n          this._end === other._end &&\n          this._step === other._step\n      : deepEqual(this, other);\n  };\n\n  return Range;\n}(IndexedSeq));\n\nvar EMPTY_RANGE;\n\n// Note: all of these methods are deprecated.\nCollection.isIterable = isCollection;\nCollection.isKeyed = isKeyed;\nCollection.isIndexed = isIndexed;\nCollection.isAssociative = isAssociative;\nCollection.isOrdered = isOrdered;\n\nCollection.Iterator = Iterator;\n\nmixin(Collection, {\n  // ### Conversion to other types\n\n  toArray: function toArray() {\n    assertNotInfinite(this.size);\n    var array = new Array(this.size || 0);\n    this.valueSeq().__iterate(function (v, i) {\n      array[i] = v;\n    });\n    return array;\n  },\n\n  toIndexedSeq: function toIndexedSeq() {\n    return new ToIndexedSequence(this);\n  },\n\n  toJS: function toJS$1() {\n    return this.toSeq().map(toJS).toJSON();\n  },\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, true);\n  },\n\n  toMap: function toMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return Map(this.toKeyedSeq());\n  },\n\n  toObject: function toObject() {\n    assertNotInfinite(this.size);\n    var object = {};\n    this.__iterate(function (v, k) {\n      object[k] = v;\n    });\n    return object;\n  },\n\n  toOrderedMap: function toOrderedMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedMap(this.toKeyedSeq());\n  },\n\n  toOrderedSet: function toOrderedSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSet: function toSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return Set(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSetSeq: function toSetSeq() {\n    return new ToSetSequence(this);\n  },\n\n  toSeq: function toSeq() {\n    return isIndexed(this)\n      ? this.toIndexedSeq()\n      : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();\n  },\n\n  toStack: function toStack() {\n    // Use Late Binding here to solve the circular dependency.\n    return Stack(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toList: function toList() {\n    // Use Late Binding here to solve the circular dependency.\n    return List(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  // ### Common JavaScript methods and properties\n\n  toString: function toString() {\n    return '[Collection]';\n  },\n\n  __toString: function __toString(head, tail) {\n    if (this.size === 0) {\n      return head + tail;\n    }\n    return head +\n      ' ' +\n      this.toSeq().map(this.__toStringMapper).join(', ') +\n      ' ' +\n      tail;\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  concat: function concat() {\n    var values = [], len = arguments.length;\n    while ( len-- ) values[ len ] = arguments[ len ];\n\n    return reify(this, concatFactory(this, values));\n  },\n\n  includes: function includes(searchValue) {\n    return this.some(function (value) { return is(value, searchValue); });\n  },\n\n  entries: function entries() {\n    return this.__iterator(ITERATE_ENTRIES);\n  },\n\n  every: function every(predicate, context) {\n    assertNotInfinite(this.size);\n    var returnValue = true;\n    this.__iterate(function (v, k, c) {\n      if (!predicate.call(context, v, k, c)) {\n        returnValue = false;\n        return false;\n      }\n    });\n    return returnValue;\n  },\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, true));\n  },\n\n  find: function find(predicate, context, notSetValue) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[1] : notSetValue;\n  },\n\n  forEach: function forEach(sideEffect, context) {\n    assertNotInfinite(this.size);\n    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n  },\n\n  join: function join(separator) {\n    assertNotInfinite(this.size);\n    separator = separator !== undefined ? '' + separator : ',';\n    var joined = '';\n    var isFirst = true;\n    this.__iterate(function (v) {\n      isFirst ? (isFirst = false) : (joined += separator);\n      joined += v !== null && v !== undefined ? v.toString() : '';\n    });\n    return joined;\n  },\n\n  keys: function keys() {\n    return this.__iterator(ITERATE_KEYS);\n  },\n\n  map: function map(mapper, context) {\n    return reify(this, mapFactory(this, mapper, context));\n  },\n\n  reduce: function reduce$1(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      false\n    );\n  },\n\n  reduceRight: function reduceRight(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      true\n    );\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, true));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, true));\n  },\n\n  some: function some(predicate, context) {\n    return !this.every(not(predicate), context);\n  },\n\n  sort: function sort(comparator) {\n    return reify(this, sortFactory(this, comparator));\n  },\n\n  values: function values() {\n    return this.__iterator(ITERATE_VALUES);\n  },\n\n  // ### More sequential methods\n\n  butLast: function butLast() {\n    return this.slice(0, -1);\n  },\n\n  isEmpty: function isEmpty() {\n    return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });\n  },\n\n  count: function count(predicate, context) {\n    return ensureSize(\n      predicate ? this.toSeq().filter(predicate, context) : this\n    );\n  },\n\n  countBy: function countBy(grouper, context) {\n    return countByFactory(this, grouper, context);\n  },\n\n  equals: function equals(other) {\n    return deepEqual(this, other);\n  },\n\n  entrySeq: function entrySeq() {\n    var collection = this;\n    if (collection._cache) {\n      // We cache as an entries array, so we can just return the cache!\n      return new ArraySeq(collection._cache);\n    }\n    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n    entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };\n\n    // Entries are plain Array, which do not define toJS, so it must\n    // manually converts keys and values before conversion.\n    entriesSequence.toJS = function() {\n      return this.map(function (entry) { return [toJS(entry[0]), toJS(entry[1])]; }).toJSON();\n    };\n\n    return entriesSequence;\n  },\n\n  filterNot: function filterNot(predicate, context) {\n    return this.filter(not(predicate), context);\n  },\n\n  findEntry: function findEntry(predicate, context, notSetValue) {\n    var found = notSetValue;\n    this.__iterate(function (v, k, c) {\n      if (predicate.call(context, v, k, c)) {\n        found = [k, v];\n        return false;\n      }\n    });\n    return found;\n  },\n\n  findKey: function findKey(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry && entry[0];\n  },\n\n  findLast: function findLast(predicate, context, notSetValue) {\n    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n  },\n\n  findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n    return this.toKeyedSeq()\n      .reverse()\n      .findEntry(predicate, context, notSetValue);\n  },\n\n  findLastKey: function findLastKey(predicate, context) {\n    return this.toKeyedSeq().reverse().findKey(predicate, context);\n  },\n\n  first: function first() {\n    return this.find(returnTrue);\n  },\n\n  flatMap: function flatMap(mapper, context) {\n    return reify(this, flatMapFactory(this, mapper, context));\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, true));\n  },\n\n  fromEntrySeq: function fromEntrySeq() {\n    return new FromEntriesSequence(this);\n  },\n\n  get: function get(searchKey, notSetValue) {\n    return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);\n  },\n\n  getIn: function getIn(searchKeyPath, notSetValue) {\n    var nested = this;\n    var keyPath = coerceKeyPath(searchKeyPath);\n    var i = 0;\n    while (i !== keyPath.length) {\n      if (!nested || !nested.get) {\n        throw new TypeError(\n          'Invalid keyPath: Value at [' +\n            keyPath.slice(0, i).map(quoteString) +\n            '] does not have a .get() method: ' +\n            nested\n        );\n      }\n      nested = nested.get(keyPath[i++], NOT_SET);\n      if (nested === NOT_SET) {\n        return notSetValue;\n      }\n    }\n    return nested;\n    // var step;\n    // while (!(step = iter.next()).done) {\n    //   var key = step.value;\n    //   nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n    //   if (nested === NOT_SET) {\n    //     return notSetValue;\n    //   }\n    // }\n    // return nested;\n  },\n\n  groupBy: function groupBy(grouper, context) {\n    return groupByFactory(this, grouper, context);\n  },\n\n  has: function has(searchKey) {\n    return this.get(searchKey, NOT_SET) !== NOT_SET;\n  },\n\n  hasIn: function hasIn(searchKeyPath) {\n    return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n  },\n\n  isSubset: function isSubset(iter) {\n    iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n    return this.every(function (value) { return iter.includes(value); });\n  },\n\n  isSuperset: function isSuperset(iter) {\n    iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n    return iter.isSubset(this);\n  },\n\n  keyOf: function keyOf(searchValue) {\n    return this.findKey(function (value) { return is(value, searchValue); });\n  },\n\n  keySeq: function keySeq() {\n    return this.toSeq().map(keyMapper).toIndexedSeq();\n  },\n\n  last: function last() {\n    return this.toSeq().reverse().first();\n  },\n\n  lastKeyOf: function lastKeyOf(searchValue) {\n    return this.toKeyedSeq().reverse().keyOf(searchValue);\n  },\n\n  max: function max(comparator) {\n    return maxFactory(this, comparator);\n  },\n\n  maxBy: function maxBy(mapper, comparator) {\n    return maxFactory(this, comparator, mapper);\n  },\n\n  min: function min(comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator\n    );\n  },\n\n  minBy: function minBy(mapper, comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator,\n      mapper\n    );\n  },\n\n  rest: function rest() {\n    return this.slice(1);\n  },\n\n  skip: function skip(amount) {\n    return amount === 0 ? this : this.slice(Math.max(0, amount));\n  },\n\n  skipLast: function skipLast(amount) {\n    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, true));\n  },\n\n  skipUntil: function skipUntil(predicate, context) {\n    return this.skipWhile(not(predicate), context);\n  },\n\n  sortBy: function sortBy(mapper, comparator) {\n    return reify(this, sortFactory(this, comparator, mapper));\n  },\n\n  take: function take(amount) {\n    return this.slice(0, Math.max(0, amount));\n  },\n\n  takeLast: function takeLast(amount) {\n    return this.slice(-Math.max(0, amount));\n  },\n\n  takeWhile: function takeWhile(predicate, context) {\n    return reify(this, takeWhileFactory(this, predicate, context));\n  },\n\n  takeUntil: function takeUntil(predicate, context) {\n    return this.takeWhile(not(predicate), context);\n  },\n\n  update: function update(fn) {\n    return fn(this);\n  },\n\n  valueSeq: function valueSeq() {\n    return this.toIndexedSeq();\n  },\n\n  // ### Hashable Object\n\n  hashCode: function hashCode() {\n    return this.__hash || (this.__hash = hashCollection(this));\n  }\n\n  // ### Internal\n\n  // abstract __iterate(fn, reverse)\n\n  // abstract __iterator(type, reverse)\n});\n\nvar CollectionPrototype = Collection.prototype;\nCollectionPrototype[IS_ITERABLE_SENTINEL] = true;\nCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\nCollectionPrototype.toJSON = CollectionPrototype.toArray;\nCollectionPrototype.__toStringMapper = quoteString;\nCollectionPrototype.inspect = (CollectionPrototype.toSource = function() {\n  return this.toString();\n});\nCollectionPrototype.chain = CollectionPrototype.flatMap;\nCollectionPrototype.contains = CollectionPrototype.includes;\n\nmixin(KeyedCollection, {\n  // ### More sequential methods\n\n  flip: function flip() {\n    return reify(this, flipFactory(this));\n  },\n\n  mapEntries: function mapEntries(mapper, context) {\n    var this$1 = this;\n\n    var iterations = 0;\n    return reify(\n      this,\n      this.toSeq()\n        .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })\n        .fromEntrySeq()\n    );\n  },\n\n  mapKeys: function mapKeys(mapper, context) {\n    var this$1 = this;\n\n    return reify(\n      this,\n      this.toSeq().flip().map(function (k, v) { return mapper.call(context, k, v, this$1); }).flip()\n    );\n  }\n});\n\nvar KeyedCollectionPrototype = KeyedCollection.prototype;\nKeyedCollectionPrototype[IS_KEYED_SENTINEL] = true;\nKeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\nKeyedCollectionPrototype.toJSON = CollectionPrototype.toObject;\nKeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };\n\nmixin(IndexedCollection, {\n  // ### Conversion to other types\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, false);\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, false));\n  },\n\n  findIndex: function findIndex(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  indexOf: function indexOf(searchValue) {\n    var key = this.keyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  lastIndexOf: function lastIndexOf(searchValue) {\n    var key = this.lastKeyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, false));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, false));\n  },\n\n  splice: function splice(index, removeNum /*, ...values*/) {\n    var numArgs = arguments.length;\n    removeNum = Math.max(removeNum || 0, 0);\n    if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n      return this;\n    }\n    // If index is negative, it should resolve relative to the size of the\n    // collection. However size may be expensive to compute if not cached, so\n    // only call count() if the number is in fact negative.\n    index = resolveBegin(index, index < 0 ? this.count() : this.size);\n    var spliced = this.slice(0, index);\n    return reify(\n      this,\n      numArgs === 1\n        ? spliced\n        : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n    );\n  },\n\n  // ### More collection methods\n\n  findLastIndex: function findLastIndex(predicate, context) {\n    var entry = this.findLastEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  first: function first() {\n    return this.get(0);\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, false));\n  },\n\n  get: function get(index, notSetValue) {\n    index = wrapIndex(this, index);\n    return index < 0 ||\n      (this.size === Infinity || (this.size !== undefined && index > this.size))\n      ? notSetValue\n      : this.find(function (_, key) { return key === index; }, undefined, notSetValue);\n  },\n\n  has: function has(index) {\n    index = wrapIndex(this, index);\n    return index >= 0 &&\n      (this.size !== undefined\n        ? this.size === Infinity || index < this.size\n        : this.indexOf(index) !== -1);\n  },\n\n  interpose: function interpose(separator) {\n    return reify(this, interposeFactory(this, separator));\n  },\n\n  interleave: function interleave(/*...collections*/) {\n    var collections = [this].concat(arrCopy(arguments));\n    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n    var interleaved = zipped.flatten(true);\n    if (zipped.size) {\n      interleaved.size = zipped.size * collections.length;\n    }\n    return reify(this, interleaved);\n  },\n\n  keySeq: function keySeq() {\n    return Range(0, this.size);\n  },\n\n  last: function last() {\n    return this.get(-1);\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, false));\n  },\n\n  zip: function zip(/*, ...collections */) {\n    var collections = [this].concat(arrCopy(arguments));\n    return reify(this, zipWithFactory(this, defaultZipper, collections));\n  },\n\n  zipWith: function zipWith(zipper /*, ...collections */) {\n    var collections = arrCopy(arguments);\n    collections[0] = this;\n    return reify(this, zipWithFactory(this, zipper, collections));\n  }\n});\n\nvar IndexedCollectionPrototype = IndexedCollection.prototype;\nIndexedCollectionPrototype[IS_INDEXED_SENTINEL] = true;\nIndexedCollectionPrototype[IS_ORDERED_SENTINEL] = true;\n\nmixin(SetCollection, {\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  get: function get(value, notSetValue) {\n    return this.has(value) ? value : notSetValue;\n  },\n\n  includes: function includes(value) {\n    return this.has(value);\n  },\n\n  // ### More sequential methods\n\n  keySeq: function keySeq() {\n    return this.valueSeq();\n  }\n});\n\nSetCollection.prototype.has = CollectionPrototype.includes;\nSetCollection.prototype.contains = SetCollection.prototype.includes;\n\n// Mixin subclasses\n\nmixin(KeyedSeq, KeyedCollection.prototype);\nmixin(IndexedSeq, IndexedCollection.prototype);\nmixin(SetSeq, SetCollection.prototype);\n\n// #pragma Helper functions\n\nfunction reduce(collection, reducer, reduction, context, useFirst, reverse) {\n  assertNotInfinite(collection.size);\n  collection.__iterate(\n    function (v, k, c) {\n      if (useFirst) {\n        useFirst = false;\n        reduction = v;\n      } else {\n        reduction = reducer.call(context, reduction, v, k, c);\n      }\n    },\n    reverse\n  );\n  return reduction;\n}\n\nfunction keyMapper(v, k) {\n  return k;\n}\n\nfunction entryMapper(v, k) {\n  return [k, v];\n}\n\nfunction toJS(value) {\n  return value && typeof value.toJS === 'function' ? value.toJS() : value;\n}\n\nfunction not(predicate) {\n  return function() {\n    return !predicate.apply(this, arguments);\n  };\n}\n\nfunction neg(predicate) {\n  return function() {\n    return -predicate.apply(this, arguments);\n  };\n}\n\nfunction defaultZipper() {\n  return arrCopy(arguments);\n}\n\nfunction defaultNegComparator(a, b) {\n  return a < b ? 1 : a > b ? -1 : 0;\n}\n\nfunction hashCollection(collection) {\n  if (collection.size === Infinity) {\n    return 0;\n  }\n  var ordered = isOrdered(collection);\n  var keyed = isKeyed(collection);\n  var h = ordered ? 1 : 0;\n  var size = collection.__iterate(\n    keyed\n      ? ordered\n          ? function (v, k) {\n              h = 31 * h + hashMerge(hash(v), hash(k)) | 0;\n            }\n          : function (v, k) {\n              h = h + hashMerge(hash(v), hash(k)) | 0;\n            }\n      : ordered\n          ? function (v) {\n              h = 31 * h + hash(v) | 0;\n            }\n          : function (v) {\n              h = h + hash(v) | 0;\n            }\n  );\n  return murmurHashOfSize(size, h);\n}\n\nfunction murmurHashOfSize(size, h) {\n  h = imul(h, 0xcc9e2d51);\n  h = imul(h << 15 | h >>> -15, 0x1b873593);\n  h = imul(h << 13 | h >>> -13, 5);\n  h = (h + 0xe6546b64 | 0) ^ size;\n  h = imul(h ^ h >>> 16, 0x85ebca6b);\n  h = imul(h ^ h >>> 13, 0xc2b2ae35);\n  h = smi(h ^ h >>> 16);\n  return h;\n}\n\nfunction hashMerge(a, b) {\n  return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int\n}\n\nvar OrderedSet = (function (Set$$1) {\n  function OrderedSet(value) {\n    return value === null || value === undefined\n      ? emptyOrderedSet()\n      : isOrderedSet(value)\n          ? value\n          : emptyOrderedSet().withMutations(function (set) {\n              var iter = SetCollection(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v) { return set.add(v); });\n            });\n  }\n\n  if ( Set$$1 ) OrderedSet.__proto__ = Set$$1;\n  OrderedSet.prototype = Object.create( Set$$1 && Set$$1.prototype );\n  OrderedSet.prototype.constructor = OrderedSet;\n\n  OrderedSet.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedSet.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  OrderedSet.prototype.toString = function toString () {\n    return this.__toString('OrderedSet {', '}');\n  };\n\n  return OrderedSet;\n}(Set));\n\nfunction isOrderedSet(maybeOrderedSet) {\n  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n}\n\nOrderedSet.isOrderedSet = isOrderedSet;\n\nvar OrderedSetPrototype = OrderedSet.prototype;\nOrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\nOrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\nOrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\n\nOrderedSetPrototype.__empty = emptyOrderedSet;\nOrderedSetPrototype.__make = makeOrderedSet;\n\nfunction makeOrderedSet(map, ownerID) {\n  var set = Object.create(OrderedSetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_ORDERED_SET;\nfunction emptyOrderedSet() {\n  return EMPTY_ORDERED_SET ||\n    (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n}\n\nvar Record = function Record(defaultValues, name) {\n  var hasInitialized;\n\n  var RecordType = function Record(values) {\n    var this$1 = this;\n\n    if (values instanceof RecordType) {\n      return values;\n    }\n    if (!(this instanceof RecordType)) {\n      return new RecordType(values);\n    }\n    if (!hasInitialized) {\n      hasInitialized = true;\n      var keys = Object.keys(defaultValues);\n      var indices = (RecordTypePrototype._indices = {});\n      RecordTypePrototype._name = name;\n      RecordTypePrototype._keys = keys;\n      RecordTypePrototype._defaultValues = defaultValues;\n      for (var i = 0; i < keys.length; i++) {\n        var propName = keys[i];\n        indices[propName] = i;\n        if (RecordTypePrototype[propName]) {\n          /* eslint-disable no-console */\n          typeof console === 'object' &&\n            console.warn &&\n            console.warn(\n              'Cannot define ' +\n                recordName(this$1) +\n                ' with property \"' +\n                propName +\n                '\" since that property name is part of the Record API.'\n            );\n          /* eslint-enable no-console */\n        } else {\n          setProp(RecordTypePrototype, propName);\n        }\n      }\n    }\n    this.__ownerID = undefined;\n    this._values = List().withMutations(function (l) {\n      l.setSize(this$1._keys.length);\n      KeyedCollection(values).forEach(function (v, k) {\n        l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);\n      });\n    });\n  };\n\n  var RecordTypePrototype = (RecordType.prototype = Object.create(\n    RecordPrototype\n  ));\n  RecordTypePrototype.constructor = RecordType;\n\n  return RecordType;\n};\n\nRecord.prototype.toString = function toString () {\n    var this$1 = this;\n\n  var str = recordName(this) + ' { ';\n  var keys = this._keys;\n  var k;\n  for (var i = 0, l = keys.length; i !== l; i++) {\n    k = keys[i];\n    str += (i ? ', ' : '') + k + ': ' + quoteString(this$1.get(k));\n  }\n  return str + ' }';\n};\n\nRecord.prototype.equals = function equals (other) {\n  return this === other ||\n    (this._keys === other._keys && recordSeq(this).equals(recordSeq(other)));\n};\n\nRecord.prototype.hashCode = function hashCode () {\n  return recordSeq(this).hashCode();\n};\n\n// @pragma Access\n\nRecord.prototype.has = function has (k) {\n  return this._indices.hasOwnProperty(k);\n};\n\nRecord.prototype.get = function get (k, notSetValue) {\n  if (!this.has(k)) {\n    return notSetValue;\n  }\n  var index = this._indices[k];\n  var value = this._values.get(index);\n  return value === undefined ? this._defaultValues[k] : value;\n};\n\n// @pragma Modification\n\nRecord.prototype.set = function set (k, v) {\n  if (this.has(k)) {\n    var newValues = this._values.set(\n      this._indices[k],\n      v === this._defaultValues[k] ? undefined : v\n    );\n    if (newValues !== this._values && !this.__ownerID) {\n      return makeRecord(this, newValues);\n    }\n  }\n  return this;\n};\n\nRecord.prototype.remove = function remove (k) {\n  return this.set(k);\n};\n\nRecord.prototype.clear = function clear () {\n  var newValues = this._values.clear().setSize(this._keys.length);\n  return this.__ownerID ? this : makeRecord(this, newValues);\n};\n\nRecord.prototype.wasAltered = function wasAltered () {\n  return this._values.wasAltered();\n};\n\nRecord.prototype.toSeq = function toSeq () {\n  return recordSeq(this);\n};\n\nRecord.prototype.toJS = function toJS () {\n  return recordSeq(this).toJS();\n};\n\nRecord.prototype.__iterator = function __iterator (type, reverse) {\n  return recordSeq(this).__iterator(type, reverse);\n};\n\nRecord.prototype.__iterate = function __iterate (fn, reverse) {\n  return recordSeq(this).__iterate(fn, reverse);\n};\n\nRecord.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n  if (ownerID === this.__ownerID) {\n    return this;\n  }\n  var newValues = this._values.__ensureOwner(ownerID);\n  if (!ownerID) {\n    this.__ownerID = ownerID;\n    this._values = newValues;\n    return this;\n  }\n  return makeRecord(this, newValues, ownerID);\n};\n\nRecord.isRecord = isRecord;\nRecord.getDescriptiveName = recordName;\nvar RecordPrototype = Record.prototype;\nRecordPrototype[IS_RECORD_SENTINEL] = true;\nRecordPrototype[DELETE] = RecordPrototype.remove;\nRecordPrototype.getIn = CollectionPrototype.getIn;\nRecordPrototype.hasIn = CollectionPrototype.hasIn;\nRecordPrototype.merge = MapPrototype.merge;\nRecordPrototype.mergeWith = MapPrototype.mergeWith;\nRecordPrototype.mergeIn = MapPrototype.mergeIn;\nRecordPrototype.mergeDeep = MapPrototype.mergeDeep;\nRecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\nRecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\nRecordPrototype.setIn = MapPrototype.setIn;\nRecordPrototype.update = MapPrototype.update;\nRecordPrototype.updateIn = MapPrototype.updateIn;\nRecordPrototype.withMutations = MapPrototype.withMutations;\nRecordPrototype.asMutable = MapPrototype.asMutable;\nRecordPrototype.asImmutable = MapPrototype.asImmutable;\nRecordPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\nRecordPrototype.toJSON = (RecordPrototype.toObject = CollectionPrototype.toObject);\nRecordPrototype.inspect = (RecordPrototype.toSource = CollectionPrototype.toSource);\n\nfunction makeRecord(likeRecord, values, ownerID) {\n  var record = Object.create(Object.getPrototypeOf(likeRecord));\n  record._values = values;\n  record.__ownerID = ownerID;\n  return record;\n}\n\nfunction recordName(record) {\n  return record._name || record.constructor.name || 'Record';\n}\n\nfunction recordSeq(record) {\n  return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));\n}\n\nfunction setProp(prototype, name) {\n  try {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  } catch (error) {\n    // Object.defineProperty failed. Probably IE8.\n  }\n}\n\n/**\n * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n * undefined, returns an infinite sequence of `value`.\n */\nvar Repeat = (function (IndexedSeq$$1) {\n  function Repeat(value, times) {\n    if (!(this instanceof Repeat)) {\n      return new Repeat(value, times);\n    }\n    this._value = value;\n    this.size = times === undefined ? Infinity : Math.max(0, times);\n    if (this.size === 0) {\n      if (EMPTY_REPEAT) {\n        return EMPTY_REPEAT;\n      }\n      EMPTY_REPEAT = this;\n    }\n  }\n\n  if ( IndexedSeq$$1 ) Repeat.__proto__ = IndexedSeq$$1;\n  Repeat.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  Repeat.prototype.constructor = Repeat;\n\n  Repeat.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Repeat []';\n    }\n    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n  };\n\n  Repeat.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._value : notSetValue;\n  };\n\n  Repeat.prototype.includes = function includes (searchValue) {\n    return is(this._value, searchValue);\n  };\n\n  Repeat.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    return wholeSlice(begin, end, size)\n      ? this\n      : new Repeat(\n          this._value,\n          resolveEnd(end, size) - resolveBegin(begin, size)\n        );\n  };\n\n  Repeat.prototype.reverse = function reverse () {\n    return this;\n  };\n\n  Repeat.prototype.indexOf = function indexOf (searchValue) {\n    if (is(this._value, searchValue)) {\n      return 0;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    if (is(this._value, searchValue)) {\n      return this.size;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var size = this.size;\n    var i = 0;\n    while (i !== size) {\n      if (fn(this$1._value, reverse ? size - ++i : i++, this$1) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  Repeat.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1 = this;\n\n    var size = this.size;\n    var i = 0;\n    return new Iterator(\n      function () { return i === size\n          ? iteratorDone()\n          : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }\n    );\n  };\n\n  Repeat.prototype.equals = function equals (other) {\n    return other instanceof Repeat\n      ? is(this._value, other._value)\n      : deepEqual(other);\n  };\n\n  return Repeat;\n}(IndexedSeq));\n\nvar EMPTY_REPEAT;\n\nvar Immutable = {\n  Collection: Collection,\n  // Note: Iterable is deprecated\n  Iterable: Collection,\n\n  Seq: Seq,\n  Map: Map,\n  OrderedMap: OrderedMap,\n  List: List,\n  Stack: Stack,\n  Set: Set,\n  OrderedSet: OrderedSet,\n\n  Record: Record,\n  Range: Range,\n  Repeat: Repeat,\n\n  is: is,\n  fromJS: fromJS,\n  hash: hash,\n\n  isImmutable: isImmutable,\n  isCollection: isCollection,\n  isKeyed: isKeyed,\n  isIndexed: isIndexed,\n  isAssociative: isAssociative,\n  isOrdered: isOrdered,\n  isValueObject: isValueObject\n};\n\n// Note: Iterable is deprecated\nvar Iterable = Collection;\n\nexports['default'] = Immutable;\nexports.Collection = Collection;\nexports.Iterable = Iterable;\nexports.Seq = Seq;\nexports.Map = Map;\nexports.OrderedMap = OrderedMap;\nexports.List = List;\nexports.Stack = Stack;\nexports.Set = Set;\nexports.OrderedSet = OrderedSet;\nexports.Record = Record;\nexports.Range = Range;\nexports.Repeat = Repeat;\nexports.is = is;\nexports.fromJS = fromJS;\nexports.hash = hash;\nexports.isImmutable = isImmutable;\nexports.isCollection = isCollection;\nexports.isKeyed = isKeyed;\nexports.isIndexed = isIndexed;\nexports.isAssociative = isAssociative;\nexports.isOrdered = isOrdered;\nexports.isValueObject = isValueObject;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8c098980c443bfaf9ae9","import { isImmutable } from 'immutable'\nimport { isFirstParamArray, reduceState, areAllFunctions } from './helpers.js'\n\nexport const pipe = (arrayOfMutators, state) => {\n  const errorInFirstParam = isFirstParamArray(arrayOfMutators)\n  if (errorInFirstParam) throw errorInFirstParam\n  return isImmutable(state)\n    ? state.withMutations(s => reduceState(arrayOfMutators, s))\n    : reduceState(arrayOfMutators, state)\n}\n\nexport const branchIf = (predicate, returnIfTrue, returnIfFalse) => state => {\n  const runIfTrue = Array.isArray(returnIfTrue) ? pipe(returnIfTrue, state) : returnIfTrue(state)\n  const runIfFalse = returnIfFalse && (Array.isArray(returnIfFalse) ? pipe(returnIfFalse, state) : returnIfFalse(state))\n  if (returnIfFalse) return predicate(state) ? runIfTrue : runIfFalse\n  return predicate(state) ? runIfTrue : state\n}\n\nexport const selector = (reducer, action) => (reducer[action.type] ? reducer[action.type](action) : reducer.DEFAULT())\n\nexport const selectorPipe = (reducer, state, action, globalMutators = []) => {\n  return reducer[action.type] ? pipe([...reducer[action.type](action), ...globalMutators], state) : reducer.DEFAULT()\n}\n\nconst createGroupMutator = (arrayOfMutators, action) => state =>\n  arrayOfMutators.map(mutator => mutator(action)).reduce((state, mutator) => mutator(state), state)\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","export const isFirstParamArray = arrayOfMutators =>\n  Array.isArray(arrayOfMutators)\n    ? false\n    : new Error('First parameter of pipe must be an array')\n\nexport const reduceState = (arrayOfMutators, state) =>\n  arrayOfMutators.reduce((state, mutator) => mutator(state), state)\n\nexport const areAllFunctions = arrayOfFunctions =>\n  arrayOfFunctions.every(func => typeof func === 'function')\n    ? false\n    : new Error('All parameters of branchIf must be functions')\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers.js","/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.Immutable = global.Immutable || {})));\n}(this, (function (exports) { 'use strict';\n\n// Used for setting prototype methods that IE8 chokes on.\nvar DELETE = 'delete';\n\n// Constants describing the size of trie nodes.\nvar SHIFT = 5; // Resulted in best performance after ______?\nvar SIZE = 1 << SHIFT;\nvar MASK = SIZE - 1;\n\n// A consistent shared value representing \"not set\" which equals nothing other\n// than itself, and nothing that could be provided externally.\nvar NOT_SET = {};\n\n// Boolean references, Rough equivalent of `bool &`.\nvar CHANGE_LENGTH = { value: false };\nvar DID_ALTER = { value: false };\n\nfunction MakeRef(ref) {\n  ref.value = false;\n  return ref;\n}\n\nfunction SetRef(ref) {\n  ref && (ref.value = true);\n}\n\n// A function which returns a value representing an \"owner\" for transient writes\n// to tries. The return value will only ever equal itself, and will not equal\n// the return of any subsequent call of this function.\nfunction OwnerID() {}\n\n// http://jsperf.com/copy-array-inline\nfunction arrCopy(arr, offset) {\n  offset = offset || 0;\n  var len = Math.max(0, arr.length - offset);\n  var newArr = new Array(len);\n  for (var ii = 0; ii < len; ii++) {\n    newArr[ii] = arr[ii + offset];\n  }\n  return newArr;\n}\n\nfunction ensureSize(iter) {\n  if (iter.size === undefined) {\n    iter.size = iter.__iterate(returnTrue);\n  }\n  return iter.size;\n}\n\nfunction wrapIndex(iter, index) {\n  // This implements \"is array index\" which the ECMAString spec defines as:\n  //\n  //     A String property name P is an array index if and only if\n  //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n  //     to 2^32−1.\n  //\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n  if (typeof index !== 'number') {\n    var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n    if ('' + uint32Index !== index || uint32Index === 4294967295) {\n      return NaN;\n    }\n    index = uint32Index;\n  }\n  return index < 0 ? ensureSize(iter) + index : index;\n}\n\nfunction returnTrue() {\n  return true;\n}\n\nfunction wholeSlice(begin, end, size) {\n  return (begin === 0 || (size !== undefined && begin <= -size)) &&\n    (end === undefined || (size !== undefined && end >= size));\n}\n\nfunction resolveBegin(begin, size) {\n  return resolveIndex(begin, size, 0);\n}\n\nfunction resolveEnd(end, size) {\n  return resolveIndex(end, size, size);\n}\n\nfunction resolveIndex(index, size, defaultIndex) {\n  // Sanitize indices using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  return index === undefined\n    ? defaultIndex\n    : index < 0\n        ? size === Infinity ? size : Math.max(0, size + index) | 0\n        : size === undefined || size === index\n            ? index\n            : Math.min(size, index) | 0;\n}\n\nfunction isImmutable(maybeImmutable) {\n  return (isCollection(maybeImmutable) || isRecord(maybeImmutable)) &&\n    !maybeImmutable.__ownerID;\n}\n\nfunction isCollection(maybeCollection) {\n  return !!(maybeCollection && maybeCollection[IS_ITERABLE_SENTINEL]);\n}\n\nfunction isKeyed(maybeKeyed) {\n  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n}\n\nfunction isIndexed(maybeIndexed) {\n  return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n}\n\nfunction isAssociative(maybeAssociative) {\n  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n}\n\nfunction isOrdered(maybeOrdered) {\n  return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n}\n\nfunction isRecord(maybeRecord) {\n  return !!(maybeRecord && maybeRecord[IS_RECORD_SENTINEL]);\n}\n\nfunction isValueObject(maybeValue) {\n  return !!(maybeValue &&\n    typeof maybeValue.equals === 'function' &&\n    typeof maybeValue.hashCode === 'function');\n}\n\nvar IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\nvar IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\nvar IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\nvar IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\nvar IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@';\n\nvar Collection = function Collection(value) {\n  return isCollection(value) ? value : Seq(value);\n};\n\nvar KeyedCollection = (function (Collection) {\n  function KeyedCollection(value) {\n    return isKeyed(value) ? value : KeyedSeq(value);\n  }\n\n  if ( Collection ) KeyedCollection.__proto__ = Collection;\n  KeyedCollection.prototype = Object.create( Collection && Collection.prototype );\n  KeyedCollection.prototype.constructor = KeyedCollection;\n\n  return KeyedCollection;\n}(Collection));\n\nvar IndexedCollection = (function (Collection) {\n  function IndexedCollection(value) {\n    return isIndexed(value) ? value : IndexedSeq(value);\n  }\n\n  if ( Collection ) IndexedCollection.__proto__ = Collection;\n  IndexedCollection.prototype = Object.create( Collection && Collection.prototype );\n  IndexedCollection.prototype.constructor = IndexedCollection;\n\n  return IndexedCollection;\n}(Collection));\n\nvar SetCollection = (function (Collection) {\n  function SetCollection(value) {\n    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n  }\n\n  if ( Collection ) SetCollection.__proto__ = Collection;\n  SetCollection.prototype = Object.create( Collection && Collection.prototype );\n  SetCollection.prototype.constructor = SetCollection;\n\n  return SetCollection;\n}(Collection));\n\nCollection.Keyed = KeyedCollection;\nCollection.Indexed = IndexedCollection;\nCollection.Set = SetCollection;\n\nvar ITERATE_KEYS = 0;\nvar ITERATE_VALUES = 1;\nvar ITERATE_ENTRIES = 2;\n\nvar REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nvar ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\nvar Iterator = function Iterator(next) {\n  this.next = next;\n};\n\nIterator.prototype.toString = function toString () {\n  return '[Iterator]';\n};\n\nIterator.KEYS = ITERATE_KEYS;\nIterator.VALUES = ITERATE_VALUES;\nIterator.ENTRIES = ITERATE_ENTRIES;\n\nIterator.prototype.inspect = (Iterator.prototype.toSource = function() {\n  return this.toString();\n});\nIterator.prototype[ITERATOR_SYMBOL] = function() {\n  return this;\n};\n\nfunction iteratorValue(type, k, v, iteratorResult) {\n  var value = type === 0 ? k : type === 1 ? v : [k, v];\n  iteratorResult\n    ? (iteratorResult.value = value)\n    : (iteratorResult = {\n        value: value,\n        done: false\n      });\n  return iteratorResult;\n}\n\nfunction iteratorDone() {\n  return { value: undefined, done: true };\n}\n\nfunction hasIterator(maybeIterable) {\n  return !!getIteratorFn(maybeIterable);\n}\n\nfunction isIterator(maybeIterator) {\n  return maybeIterator && typeof maybeIterator.next === 'function';\n}\n\nfunction getIterator(iterable) {\n  var iteratorFn = getIteratorFn(iterable);\n  return iteratorFn && iteratorFn.call(iterable);\n}\n\nfunction getIteratorFn(iterable) {\n  var iteratorFn = iterable &&\n    ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]);\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n}\n\nfunction isArrayLike(value) {\n  return value && typeof value.length === 'number';\n}\n\nvar Seq = (function (Collection$$1) {\n  function Seq(value) {\n    return value === null || value === undefined\n      ? emptySequence()\n      : isCollection(value) || isRecord(value)\n          ? value.toSeq()\n          : seqFromValue(value);\n  }\n\n  if ( Collection$$1 ) Seq.__proto__ = Collection$$1;\n  Seq.prototype = Object.create( Collection$$1 && Collection$$1.prototype );\n  Seq.prototype.constructor = Seq;\n\n  Seq.of = function of (/*...values*/) {\n    return Seq(arguments);\n  };\n\n  Seq.prototype.toSeq = function toSeq () {\n    return this;\n  };\n\n  Seq.prototype.toString = function toString () {\n    return this.__toString('Seq {', '}');\n  };\n\n  Seq.prototype.cacheResult = function cacheResult () {\n    if (!this._cache && this.__iterateUncached) {\n      this._cache = this.entrySeq().toArray();\n      this.size = this._cache.length;\n    }\n    return this;\n  };\n\n  // abstract __iterateUncached(fn, reverse)\n\n  Seq.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      while (i !== size) {\n        var entry = cache[reverse ? size - ++i : i++];\n        if (fn(entry[1], entry[0], this$1) === false) {\n          break;\n        }\n      }\n      return i;\n    }\n    return this.__iterateUncached(fn, reverse);\n  };\n\n  // abstract __iteratorUncached(type, reverse)\n\n  Seq.prototype.__iterator = function __iterator (type, reverse) {\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var entry = cache[reverse ? size - ++i : i++];\n        return iteratorValue(type, entry[0], entry[1]);\n      });\n    }\n    return this.__iteratorUncached(type, reverse);\n  };\n\n  return Seq;\n}(Collection));\n\nvar KeyedSeq = (function (Seq) {\n  function KeyedSeq(value) {\n    return value === null || value === undefined\n      ? emptySequence().toKeyedSeq()\n      : isCollection(value)\n          ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq()\n          : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);\n  }\n\n  if ( Seq ) KeyedSeq.__proto__ = Seq;\n  KeyedSeq.prototype = Object.create( Seq && Seq.prototype );\n  KeyedSeq.prototype.constructor = KeyedSeq;\n\n  KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {\n    return this;\n  };\n\n  return KeyedSeq;\n}(Seq));\n\nvar IndexedSeq = (function (Seq) {\n  function IndexedSeq(value) {\n    return value === null || value === undefined\n      ? emptySequence()\n      : isCollection(value)\n          ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq()\n          : isRecord(value)\n              ? value.toSeq().entrySeq()\n              : indexedSeqFromValue(value);\n  }\n\n  if ( Seq ) IndexedSeq.__proto__ = Seq;\n  IndexedSeq.prototype = Object.create( Seq && Seq.prototype );\n  IndexedSeq.prototype.constructor = IndexedSeq;\n\n  IndexedSeq.of = function of (/*...values*/) {\n    return IndexedSeq(arguments);\n  };\n\n  IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {\n    return this;\n  };\n\n  IndexedSeq.prototype.toString = function toString () {\n    return this.__toString('Seq [', ']');\n  };\n\n  return IndexedSeq;\n}(Seq));\n\nvar SetSeq = (function (Seq) {\n  function SetSeq(value) {\n    return (isCollection(value) && !isAssociative(value)\n      ? value\n      : IndexedSeq(value)).toSetSeq();\n  }\n\n  if ( Seq ) SetSeq.__proto__ = Seq;\n  SetSeq.prototype = Object.create( Seq && Seq.prototype );\n  SetSeq.prototype.constructor = SetSeq;\n\n  SetSeq.of = function of (/*...values*/) {\n    return SetSeq(arguments);\n  };\n\n  SetSeq.prototype.toSetSeq = function toSetSeq () {\n    return this;\n  };\n\n  return SetSeq;\n}(Seq));\n\nSeq.isSeq = isSeq;\nSeq.Keyed = KeyedSeq;\nSeq.Set = SetSeq;\nSeq.Indexed = IndexedSeq;\n\nvar IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\nSeq.prototype[IS_SEQ_SENTINEL] = true;\n\n// #pragma Root Sequences\n\nvar ArraySeq = (function (IndexedSeq) {\n  function ArraySeq(array) {\n    this._array = array;\n    this.size = array.length;\n  }\n\n  if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;\n  ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  ArraySeq.prototype.constructor = ArraySeq;\n\n  ArraySeq.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n  };\n\n  ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    while (i !== size) {\n      var ii = reverse ? size - ++i : i++;\n      if (fn(array[ii], ii, this$1) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ArraySeq.prototype.__iterator = function __iterator (type, reverse) {\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var ii = reverse ? size - ++i : i++;\n      return iteratorValue(type, ii, array[ii]);\n    });\n  };\n\n  return ArraySeq;\n}(IndexedSeq));\n\nvar ObjectSeq = (function (KeyedSeq) {\n  function ObjectSeq(object) {\n    var keys = Object.keys(object);\n    this._object = object;\n    this._keys = keys;\n    this.size = keys.length;\n  }\n\n  if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;\n  ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n  ObjectSeq.prototype.constructor = ObjectSeq;\n\n  ObjectSeq.prototype.get = function get (key, notSetValue) {\n    if (notSetValue !== undefined && !this.has(key)) {\n      return notSetValue;\n    }\n    return this._object[key];\n  };\n\n  ObjectSeq.prototype.has = function has (key) {\n    return this._object.hasOwnProperty(key);\n  };\n\n  ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    while (i !== size) {\n      var key = keys[reverse ? size - ++i : i++];\n      if (fn(object[key], key, this$1) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var key = keys[reverse ? size - ++i : i++];\n      return iteratorValue(type, key, object[key]);\n    });\n  };\n\n  return ObjectSeq;\n}(KeyedSeq));\nObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\nvar CollectionSeq = (function (IndexedSeq) {\n  function CollectionSeq(collection) {\n    this._collection = collection;\n    this.size = collection.length || collection.size;\n  }\n\n  if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;\n  CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  CollectionSeq.prototype.constructor = CollectionSeq;\n\n  CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    var iterations = 0;\n    if (isIterator(iterator)) {\n      var step;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this$1) === false) {\n          break;\n        }\n      }\n    }\n    return iterations;\n  };\n\n  CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    if (!isIterator(iterator)) {\n      return new Iterator(iteratorDone);\n    }\n    var iterations = 0;\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done ? step : iteratorValue(type, iterations++, step.value);\n    });\n  };\n\n  return CollectionSeq;\n}(IndexedSeq));\n\nvar IteratorSeq = (function (IndexedSeq) {\n  function IteratorSeq(iterator) {\n    this._iterator = iterator;\n    this._iteratorCache = [];\n  }\n\n  if ( IndexedSeq ) IteratorSeq.__proto__ = IndexedSeq;\n  IteratorSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  IteratorSeq.prototype.constructor = IteratorSeq;\n\n  IteratorSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterator = this._iterator;\n    var cache = this._iteratorCache;\n    var iterations = 0;\n    while (iterations < cache.length) {\n      if (fn(cache[iterations], iterations++, this$1) === false) {\n        return iterations;\n      }\n    }\n    var step;\n    while (!(step = iterator.next()).done) {\n      var val = step.value;\n      cache[iterations] = val;\n      if (fn(val, iterations++, this$1) === false) {\n        break;\n      }\n    }\n    return iterations;\n  };\n\n  IteratorSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = this._iterator;\n    var cache = this._iteratorCache;\n    var iterations = 0;\n    return new Iterator(function () {\n      if (iterations >= cache.length) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        cache[iterations] = step.value;\n      }\n      return iteratorValue(type, iterations, cache[iterations++]);\n    });\n  };\n\n  return IteratorSeq;\n}(IndexedSeq));\n\n// # pragma Helper functions\n\nfunction isSeq(maybeSeq) {\n  return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n}\n\nvar EMPTY_SEQ;\n\nfunction emptySequence() {\n  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n}\n\nfunction keyedSeqFromValue(value) {\n  var seq = Array.isArray(value)\n    ? new ArraySeq(value)\n    : isIterator(value)\n        ? new IteratorSeq(value)\n        : hasIterator(value) ? new CollectionSeq(value) : undefined;\n  if (seq) {\n    return seq.fromEntrySeq();\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of [k, v] entries, or keyed object: ' +\n      value\n  );\n}\n\nfunction indexedSeqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq;\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values: ' + value\n  );\n}\n\nfunction seqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq;\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values, or keyed object: ' + value\n  );\n}\n\nfunction maybeIndexedSeqFromValue(value) {\n  return isArrayLike(value)\n    ? new ArraySeq(value)\n    : isIterator(value)\n        ? new IteratorSeq(value)\n        : hasIterator(value) ? new CollectionSeq(value) : undefined;\n}\n\n/**\n * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n *\n * NaN is considered the same as NaN, however -0 and 0 are considered the same\n * value, which is different from the algorithm described by\n * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n *\n * This is extended further to allow Objects to describe the values they\n * represent, by way of `valueOf` or `equals` (and `hashCode`).\n *\n * Note: because of this extension, the key equality of Immutable.Map and the\n * value equality of Immutable.Set will differ from ES6 Map and Set.\n *\n * ### Defining custom values\n *\n * The easiest way to describe the value an object represents is by implementing\n * `valueOf`. For example, `Date` represents a value by returning a unix\n * timestamp for `valueOf`:\n *\n *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n *     var date2 = new Date(1234567890000);\n *     date1.valueOf(); // 1234567890000\n *     assert( date1 !== date2 );\n *     assert( Immutable.is( date1, date2 ) );\n *\n * Note: overriding `valueOf` may have other implications if you use this object\n * where JavaScript expects a primitive, such as implicit string coercion.\n *\n * For more complex types, especially collections, implementing `valueOf` may\n * not be performant. An alternative is to implement `equals` and `hashCode`.\n *\n * `equals` takes another object, presumably of similar type, and returns true\n * if it is equal. Equality is symmetrical, so the same result should be\n * returned if this and the argument are flipped.\n *\n *     assert( a.equals(b) === b.equals(a) );\n *\n * `hashCode` returns a 32bit integer number representing the object which will\n * be used to determine how to store the value object in a Map or Set. You must\n * provide both or neither methods, one must not exist without the other.\n *\n * Also, an important relationship between these methods must be upheld: if two\n * values are equal, they *must* return the same hashCode. If the values are not\n * equal, they might have the same hashCode; this is called a hash collision,\n * and while undesirable for performance reasons, it is acceptable.\n *\n *     if (a.equals(b)) {\n *       assert( a.hashCode() === b.hashCode() );\n *     }\n *\n * All Immutable collections are Value Objects: they implement `equals()`\n * and `hashCode()`.\n */\nfunction is(valueA, valueB) {\n  if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n    return true;\n  }\n  if (!valueA || !valueB) {\n    return false;\n  }\n  if (\n    typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function'\n  ) {\n    valueA = valueA.valueOf();\n    valueB = valueB.valueOf();\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n  }\n  return !!(isValueObject(valueA) &&\n    isValueObject(valueB) &&\n    valueA.equals(valueB));\n}\n\nfunction fromJS(value, converter) {\n  return fromJSWith(\n    [],\n    converter || defaultConverter,\n    value,\n    '',\n    converter && converter.length > 2 ? [] : undefined,\n    { '': value }\n  );\n}\n\nfunction fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n  var toSeq = Array.isArray(value)\n    ? IndexedSeq\n    : isPlainObj(value) ? KeyedSeq : null;\n  if (toSeq) {\n    if (~stack.indexOf(value)) {\n      throw new TypeError('Cannot convert circular structure to Immutable');\n    }\n    stack.push(value);\n    keyPath && key !== '' && keyPath.push(key);\n    var converted = converter.call(\n      parentValue,\n      key,\n      toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }),\n      keyPath && keyPath.slice()\n    );\n    stack.pop();\n    keyPath && keyPath.pop();\n    return converted;\n  }\n  return value;\n}\n\nfunction defaultConverter(k, v) {\n  return isKeyed(v) ? v.toMap() : v.toList();\n}\n\nfunction isPlainObj(value) {\n  return value &&\n    (value.constructor === Object || value.constructor === undefined);\n}\n\nvar imul = typeof Math.imul === 'function' &&\n  Math.imul(0xffffffff, 2) === -2\n  ? Math.imul\n  : function imul(a, b) {\n      a |= 0; // int\n      b |= 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int\n    };\n\n// v8 has an optimization for storing 31-bit signed numbers.\n// Values which have either 00 or 11 as the high order bits qualify.\n// This function drops the highest order bit in a signed number, maintaining\n// the sign bit.\nfunction smi(i32) {\n  return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;\n}\n\nfunction hash(o) {\n  if (o === false || o === null || o === undefined) {\n    return 0;\n  }\n  if (typeof o.valueOf === 'function') {\n    o = o.valueOf();\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n  }\n  if (o === true) {\n    return 1;\n  }\n  var type = typeof o;\n  if (type === 'number') {\n    if (o !== o || o === Infinity) {\n      return 0;\n    }\n    var h = o | 0;\n    if (h !== o) {\n      h ^= o * 0xffffffff;\n    }\n    while (o > 0xffffffff) {\n      o /= 0xffffffff;\n      h ^= o;\n    }\n    return smi(h);\n  }\n  if (type === 'string') {\n    return o.length > STRING_HASH_CACHE_MIN_STRLEN\n      ? cachedHashString(o)\n      : hashString(o);\n  }\n  if (typeof o.hashCode === 'function') {\n    return o.hashCode();\n  }\n  if (type === 'object') {\n    return hashJSObj(o);\n  }\n  if (typeof o.toString === 'function') {\n    return hashString(o.toString());\n  }\n  throw new Error('Value type ' + type + ' cannot be hashed.');\n}\n\nfunction cachedHashString(string) {\n  var hash = stringHashCache[string];\n  if (hash === undefined) {\n    hash = hashString(string);\n    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n      STRING_HASH_CACHE_SIZE = 0;\n      stringHashCache = {};\n    }\n    STRING_HASH_CACHE_SIZE++;\n    stringHashCache[string] = hash;\n  }\n  return hash;\n}\n\n// http://jsperf.com/hashing-strings\nfunction hashString(string) {\n  // This is the hash from JVM\n  // The hash code for a string is computed as\n  // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n  // where s[i] is the ith character of the string and n is the length of\n  // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n  // (exclusive) by dropping high bits.\n  var hash = 0;\n  for (var ii = 0; ii < string.length; ii++) {\n    hash = 31 * hash + string.charCodeAt(ii) | 0;\n  }\n  return smi(hash);\n}\n\nfunction hashJSObj(obj) {\n  var hash;\n  if (usingWeakMap) {\n    hash = weakMap.get(obj);\n    if (hash !== undefined) {\n      return hash;\n    }\n  }\n\n  hash = obj[UID_HASH_KEY];\n  if (hash !== undefined) {\n    return hash;\n  }\n\n  if (!canDefineProperty) {\n    hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    hash = getIENodeHash(obj);\n    if (hash !== undefined) {\n      return hash;\n    }\n  }\n\n  hash = ++objHashUID;\n  if (objHashUID & 0x40000000) {\n    objHashUID = 0;\n  }\n\n  if (usingWeakMap) {\n    weakMap.set(obj, hash);\n  } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n    throw new Error('Non-extensible objects are not allowed as keys.');\n  } else if (canDefineProperty) {\n    Object.defineProperty(obj, UID_HASH_KEY, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: hash\n    });\n  } else if (\n    obj.propertyIsEnumerable !== undefined &&\n    obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable\n  ) {\n    // Since we can't define a non-enumerable property on the object\n    // we'll hijack one of the less-used non-enumerable properties to\n    // save our hash on it. Since this is a function it will not show up in\n    // `JSON.stringify` which is what we want.\n    obj.propertyIsEnumerable = function() {\n      return this.constructor.prototype.propertyIsEnumerable.apply(\n        this,\n        arguments\n      );\n    };\n    obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n  } else if (obj.nodeType !== undefined) {\n    // At this point we couldn't get the IE `uniqueID` to use as a hash\n    // and we couldn't use a non-enumerable property to exploit the\n    // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n    // itself.\n    obj[UID_HASH_KEY] = hash;\n  } else {\n    throw new Error('Unable to set a non-enumerable property on object.');\n  }\n\n  return hash;\n}\n\n// Get references to ES5 object methods.\nvar isExtensible = Object.isExtensible;\n\n// True if Object.defineProperty works as expected. IE8 fails this test.\nvar canDefineProperty = (function() {\n  try {\n    Object.defineProperty({}, '@', {});\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();\n\n// IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n// and avoid memory leaks from the IE cloneNode bug.\nfunction getIENodeHash(node) {\n  if (node && node.nodeType > 0) {\n    switch (node.nodeType) {\n      case 1: // Element\n        return node.uniqueID;\n      case 9: // Document\n        return node.documentElement && node.documentElement.uniqueID;\n    }\n  }\n}\n\n// If possible, use a WeakMap.\nvar usingWeakMap = typeof WeakMap === 'function';\nvar weakMap;\nif (usingWeakMap) {\n  weakMap = new WeakMap();\n}\n\nvar objHashUID = 0;\n\nvar UID_HASH_KEY = '__immutablehash__';\nif (typeof Symbol === 'function') {\n  UID_HASH_KEY = Symbol(UID_HASH_KEY);\n}\n\nvar STRING_HASH_CACHE_MIN_STRLEN = 16;\nvar STRING_HASH_CACHE_MAX_SIZE = 255;\nvar STRING_HASH_CACHE_SIZE = 0;\nvar stringHashCache = {};\n\nvar ToKeyedSequence = (function (KeyedSeq$$1) {\n  function ToKeyedSequence(indexed, useKeys) {\n    this._iter = indexed;\n    this._useKeys = useKeys;\n    this.size = indexed.size;\n  }\n\n  if ( KeyedSeq$$1 ) ToKeyedSequence.__proto__ = KeyedSeq$$1;\n  ToKeyedSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );\n  ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n  ToKeyedSequence.prototype.get = function get (key, notSetValue) {\n    return this._iter.get(key, notSetValue);\n  };\n\n  ToKeyedSequence.prototype.has = function has (key) {\n    return this._iter.has(key);\n  };\n\n  ToKeyedSequence.prototype.valueSeq = function valueSeq () {\n    return this._iter.valueSeq();\n  };\n\n  ToKeyedSequence.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var reversedSequence = reverseFactory(this, true);\n    if (!this._useKeys) {\n      reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };\n    }\n    return reversedSequence;\n  };\n\n  ToKeyedSequence.prototype.map = function map (mapper, context) {\n    var this$1 = this;\n\n    var mappedSequence = mapFactory(this, mapper, context);\n    if (!this._useKeys) {\n      mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };\n    }\n    return mappedSequence;\n  };\n\n  ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);\n  };\n\n  ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    return this._iter.__iterator(type, reverse);\n  };\n\n  return ToKeyedSequence;\n}(KeyedSeq));\nToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\nvar ToIndexedSequence = (function (IndexedSeq$$1) {\n  function ToIndexedSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( IndexedSeq$$1 ) ToIndexedSequence.__proto__ = IndexedSeq$$1;\n  ToIndexedSequence.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n  ToIndexedSequence.prototype.includes = function includes (value) {\n    return this._iter.includes(value);\n  };\n\n  ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(this);\n    return this._iter.__iterate(\n      function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },\n      reverse\n    );\n  };\n\n  ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1 = this;\n\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    var i = 0;\n    reverse && ensureSize(this);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(\n            type,\n            reverse ? this$1.size - ++i : i++,\n            step.value,\n            step\n          );\n    });\n  };\n\n  return ToIndexedSequence;\n}(IndexedSeq));\n\nvar ToSetSequence = (function (SetSeq$$1) {\n  function ToSetSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( SetSeq$$1 ) ToSetSequence.__proto__ = SetSeq$$1;\n  ToSetSequence.prototype = Object.create( SetSeq$$1 && SetSeq$$1.prototype );\n  ToSetSequence.prototype.constructor = ToSetSequence;\n\n  ToSetSequence.prototype.has = function has (key) {\n    return this._iter.includes(key);\n  };\n\n  ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);\n  };\n\n  ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(type, step.value, step.value, step);\n    });\n  };\n\n  return ToSetSequence;\n}(SetSeq));\n\nvar FromEntriesSequence = (function (KeyedSeq$$1) {\n  function FromEntriesSequence(entries) {\n    this._iter = entries;\n    this.size = entries.size;\n  }\n\n  if ( KeyedSeq$$1 ) FromEntriesSequence.__proto__ = KeyedSeq$$1;\n  FromEntriesSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );\n  FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n  FromEntriesSequence.prototype.entrySeq = function entrySeq () {\n    return this._iter.toSeq();\n  };\n\n  FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(\n      function (entry) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return fn(\n            indexedCollection ? entry.get(1) : entry[1],\n            indexedCollection ? entry.get(0) : entry[0],\n            this$1\n          );\n        }\n      },\n      reverse\n    );\n  };\n\n  FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return iteratorValue(\n            type,\n            indexedCollection ? entry.get(0) : entry[0],\n            indexedCollection ? entry.get(1) : entry[1],\n            step\n          );\n        }\n      }\n    });\n  };\n\n  return FromEntriesSequence;\n}(KeyedSeq));\n\nToIndexedSequence.prototype.cacheResult = (ToKeyedSequence.prototype.cacheResult = (ToSetSequence.prototype.cacheResult = (FromEntriesSequence.prototype.cacheResult = cacheResultThrough)));\n\nfunction flipFactory(collection) {\n  var flipSequence = makeSequence(collection);\n  flipSequence._iter = collection;\n  flipSequence.size = collection.size;\n  flipSequence.flip = function () { return collection; };\n  flipSequence.reverse = function() {\n    var reversedSequence = collection.reverse.apply(this); // super.reverse()\n    reversedSequence.flip = function () { return collection.reverse(); };\n    return reversedSequence;\n  };\n  flipSequence.has = function (key) { return collection.includes(key); };\n  flipSequence.includes = function (key) { return collection.has(key); };\n  flipSequence.cacheResult = cacheResultThrough;\n  flipSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);\n  };\n  flipSequence.__iteratorUncached = function(type, reverse) {\n    if (type === ITERATE_ENTRIES) {\n      var iterator = collection.__iterator(type, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (!step.done) {\n          var k = step.value[0];\n          step.value[0] = step.value[1];\n          step.value[1] = k;\n        }\n        return step;\n      });\n    }\n    return collection.__iterator(\n      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n      reverse\n    );\n  };\n  return flipSequence;\n}\n\nfunction mapFactory(collection, mapper, context) {\n  var mappedSequence = makeSequence(collection);\n  mappedSequence.size = collection.size;\n  mappedSequence.has = function (key) { return collection.has(key); };\n  mappedSequence.get = function (key, notSetValue) {\n    var v = collection.get(key, NOT_SET);\n    return v === NOT_SET\n      ? notSetValue\n      : mapper.call(context, v, key, collection);\n  };\n  mappedSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    return collection.__iterate(\n      function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },\n      reverse\n    );\n  };\n  mappedSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var key = entry[0];\n      return iteratorValue(\n        type,\n        key,\n        mapper.call(context, entry[1], key, collection),\n        step\n      );\n    });\n  };\n  return mappedSequence;\n}\n\nfunction reverseFactory(collection, useKeys) {\n  var this$1 = this;\n\n  var reversedSequence = makeSequence(collection);\n  reversedSequence._iter = collection;\n  reversedSequence.size = collection.size;\n  reversedSequence.reverse = function () { return collection; };\n  if (collection.flip) {\n    reversedSequence.flip = function() {\n      var flipSequence = flipFactory(collection);\n      flipSequence.reverse = function () { return collection.flip(); };\n      return flipSequence;\n    };\n  }\n  reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };\n  reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };\n  reversedSequence.includes = function (value) { return collection.includes(value); };\n  reversedSequence.cacheResult = cacheResultThrough;\n  reversedSequence.__iterate = function(fn, reverse) {\n    var this$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(collection);\n    return collection.__iterate(\n      function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },\n      !reverse\n    );\n  };\n  reversedSequence.__iterator = function (type, reverse) {\n    var i = 0;\n    reverse && ensureSize(collection);\n    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      return iteratorValue(\n        type,\n        useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,\n        entry[1],\n        step\n      );\n    });\n  };\n  return reversedSequence;\n}\n\nfunction filterFactory(collection, predicate, context, useKeys) {\n  var filterSequence = makeSequence(collection);\n  if (useKeys) {\n    filterSequence.has = function (key) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n    };\n    filterSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && predicate.call(context, v, key, collection)\n        ? v\n        : notSetValue;\n    };\n  }\n  filterSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(\n      function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          return fn(v, useKeys ? k : iterations++, this$1);\n        }\n      },\n      reverse\n    );\n    return iterations;\n  };\n  filterSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterations = 0;\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        var value = entry[1];\n        if (predicate.call(context, value, key, collection)) {\n          return iteratorValue(type, useKeys ? key : iterations++, value, step);\n        }\n      }\n    });\n  };\n  return filterSequence;\n}\n\nfunction countByFactory(collection, grouper, context) {\n  var groups = Map().asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });\n  });\n  return groups.asImmutable();\n}\n\nfunction groupByFactory(collection, grouper, context) {\n  var isKeyedIter = isKeyed(collection);\n  var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(\n      grouper.call(context, v, k, collection),\n      function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }\n    );\n  });\n  var coerce = collectionClass(collection);\n  return groups.map(function (arr) { return reify(collection, coerce(arr)); });\n}\n\nfunction sliceFactory(collection, begin, end, useKeys) {\n  var originalSize = collection.size;\n\n  if (wholeSlice(begin, end, originalSize)) {\n    return collection;\n  }\n\n  var resolvedBegin = resolveBegin(begin, originalSize);\n  var resolvedEnd = resolveEnd(end, originalSize);\n\n  // begin or end will be NaN if they were provided as negative numbers and\n  // this collection's size is unknown. In that case, cache first so there is\n  // a known size and these do not resolve to NaN.\n  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n  }\n\n  // Note: resolvedEnd is undefined when the original sequence's length is\n  // unknown and this slice did not supply an end and should contain all\n  // elements after resolvedBegin.\n  // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n  var resolvedSize = resolvedEnd - resolvedBegin;\n  var sliceSize;\n  if (resolvedSize === resolvedSize) {\n    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n  }\n\n  var sliceSeq = makeSequence(collection);\n\n  // If collection.size is undefined, the size of the realized sliceSeq is\n  // unknown at this point unless the number of items to slice is 0\n  sliceSeq.size = sliceSize === 0\n    ? sliceSize\n    : (collection.size && sliceSize) || undefined;\n\n  if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n    sliceSeq.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index >= 0 && index < sliceSize\n        ? collection.get(index + resolvedBegin, notSetValue)\n        : notSetValue;\n    };\n  }\n\n  sliceSeq.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (sliceSize === 0) {\n      return 0;\n    }\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var skipped = 0;\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k) {\n      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1) !== false &&\n          iterations !== sliceSize;\n      }\n    });\n    return iterations;\n  };\n\n  sliceSeq.__iteratorUncached = function(type, reverse) {\n    if (sliceSize !== 0 && reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    // Don't bother instantiating parent iterator if taking 0.\n    var iterator = sliceSize !== 0 && collection.__iterator(type, reverse);\n    var skipped = 0;\n    var iterations = 0;\n    return new Iterator(function () {\n      while (skipped++ < resolvedBegin) {\n        iterator.next();\n      }\n      if (++iterations > sliceSize) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (useKeys || type === ITERATE_VALUES) {\n        return step;\n      }\n      if (type === ITERATE_KEYS) {\n        return iteratorValue(type, iterations - 1, undefined, step);\n      }\n      return iteratorValue(type, iterations - 1, step.value[1], step);\n    });\n  };\n\n  return sliceSeq;\n}\n\nfunction takeWhileFactory(collection, predicate, context) {\n  var takeSequence = makeSequence(collection);\n  takeSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    collection.__iterate(\n      function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }\n    );\n    return iterations;\n  };\n  takeSequence.__iteratorUncached = function(type, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterating = true;\n    return new Iterator(function () {\n      if (!iterating) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var k = entry[0];\n      var v = entry[1];\n      if (!predicate.call(context, v, k, this$1)) {\n        iterating = false;\n        return iteratorDone();\n      }\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return takeSequence;\n}\n\nfunction skipWhileFactory(collection, predicate, context, useKeys) {\n  var skipSequence = makeSequence(collection);\n  skipSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k, c) {\n      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1);\n      }\n    });\n    return iterations;\n  };\n  skipSequence.__iteratorUncached = function(type, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var skipping = true;\n    var iterations = 0;\n    return new Iterator(function () {\n      var step;\n      var k;\n      var v;\n      do {\n        step = iterator.next();\n        if (step.done) {\n          if (useKeys || type === ITERATE_VALUES) {\n            return step;\n          }\n          if (type === ITERATE_KEYS) {\n            return iteratorValue(type, iterations++, undefined, step);\n          }\n          return iteratorValue(type, iterations++, step.value[1], step);\n        }\n        var entry = step.value;\n        k = entry[0];\n        v = entry[1];\n        skipping && (skipping = predicate.call(context, v, k, this$1));\n      } while (skipping);\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return skipSequence;\n}\n\nfunction concatFactory(collection, values) {\n  var isKeyedCollection = isKeyed(collection);\n  var iters = [collection]\n    .concat(values)\n    .map(function (v) {\n      if (!isCollection(v)) {\n        v = isKeyedCollection\n          ? keyedSeqFromValue(v)\n          : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedCollection) {\n        v = KeyedCollection(v);\n      }\n      return v;\n    })\n    .filter(function (v) { return v.size !== 0; });\n\n  if (iters.length === 0) {\n    return collection;\n  }\n\n  if (iters.length === 1) {\n    var singleton = iters[0];\n    if (\n      singleton === collection ||\n      (isKeyedCollection && isKeyed(singleton)) ||\n      (isIndexed(collection) && isIndexed(singleton))\n    ) {\n      return singleton;\n    }\n  }\n\n  var concatSeq = new ArraySeq(iters);\n  if (isKeyedCollection) {\n    concatSeq = concatSeq.toKeyedSeq();\n  } else if (!isIndexed(collection)) {\n    concatSeq = concatSeq.toSetSeq();\n  }\n  concatSeq = concatSeq.flatten(true);\n  concatSeq.size = iters.reduce(\n    function (sum, seq) {\n      if (sum !== undefined) {\n        var size = seq.size;\n        if (size !== undefined) {\n          return sum + size;\n        }\n      }\n    },\n    0\n  );\n  return concatSeq;\n}\n\nfunction flattenFactory(collection, depth, useKeys) {\n  var flatSequence = makeSequence(collection);\n  flatSequence.__iterateUncached = function(fn, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    var stopped = false;\n    function flatDeep(iter, currentDepth) {\n      iter.__iterate(\n        function (v, k) {\n          if ((!depth || currentDepth < depth) && isCollection(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (\n            fn(v, useKeys ? k : iterations++, flatSequence) === false\n          ) {\n            stopped = true;\n          }\n          return !stopped;\n        },\n        reverse\n      );\n    }\n    flatDeep(collection, 0);\n    return iterations;\n  };\n  flatSequence.__iteratorUncached = function(type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(type, reverse);\n    var stack = [];\n    var iterations = 0;\n    return new Iterator(function () {\n      while (iterator) {\n        var step = iterator.next();\n        if (step.done !== false) {\n          iterator = stack.pop();\n          continue;\n        }\n        var v = step.value;\n        if (type === ITERATE_ENTRIES) {\n          v = v[1];\n        }\n        if ((!depth || stack.length < depth) && isCollection(v)) {\n          stack.push(iterator);\n          iterator = v.__iterator(type, reverse);\n        } else {\n          return useKeys ? step : iteratorValue(type, iterations++, v, step);\n        }\n      }\n      return iteratorDone();\n    });\n  };\n  return flatSequence;\n}\n\nfunction flatMapFactory(collection, mapper, context) {\n  var coerce = collectionClass(collection);\n  return collection\n    .toSeq()\n    .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })\n    .flatten(true);\n}\n\nfunction interposeFactory(collection, separator) {\n  var interposedSequence = makeSequence(collection);\n  interposedSequence.size = collection.size && collection.size * 2 - 1;\n  interposedSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(\n      function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&\n        fn(v, iterations++, this$1) !== false; },\n      reverse\n    );\n    return iterations;\n  };\n  interposedSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n    var iterations = 0;\n    var step;\n    return new Iterator(function () {\n      if (!step || iterations % 2) {\n        step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n      }\n      return iterations % 2\n        ? iteratorValue(type, iterations++, separator)\n        : iteratorValue(type, iterations++, step.value, step);\n    });\n  };\n  return interposedSequence;\n}\n\nfunction sortFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  var isKeyedCollection = isKeyed(collection);\n  var index = 0;\n  var entries = collection\n    .toSeq()\n    .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })\n    .toArray();\n  entries.sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; }).forEach(\n    isKeyedCollection\n      ? function (v, i) {\n          entries[i].length = 2;\n        }\n      : function (v, i) {\n          entries[i] = v[1];\n        }\n  );\n  return isKeyedCollection\n    ? KeyedSeq(entries)\n    : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);\n}\n\nfunction maxFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  if (mapper) {\n    var entry = collection\n      .toSeq()\n      .map(function (v, k) { return [v, mapper(v, k, collection)]; })\n      .reduce(function (a, b) { return maxCompare(comparator, a[1], b[1]) ? b : a; });\n    return entry && entry[0];\n  }\n  return collection.reduce(function (a, b) { return maxCompare(comparator, a, b) ? b : a; });\n}\n\nfunction maxCompare(comparator, a, b) {\n  var comp = comparator(b, a);\n  // b is considered the new max if the comparator declares them equal, but\n  // they are not equal and b is in fact a nullish value.\n  return (comp === 0 &&\n    b !== a &&\n    (b === undefined || b === null || b !== b)) ||\n    comp > 0;\n}\n\nfunction zipWithFactory(keyIter, zipper, iters) {\n  var zipSequence = makeSequence(keyIter);\n  zipSequence.size = new ArraySeq(iters).map(function (i) { return i.size; }).min();\n  // Note: this a generic base implementation of __iterate in terms of\n  // __iterator which may be more generically useful in the future.\n  zipSequence.__iterate = function(fn, reverse) {\n    var this$1 = this;\n\n    /* generic:\n    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      iterations++;\n      if (fn(step.value[1], step.value[0], this) === false) {\n        break;\n      }\n    }\n    return iterations;\n    */\n    // indexed:\n    var iterator = this.__iterator(ITERATE_VALUES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      if (fn(step.value, iterations++, this$1) === false) {\n        break;\n      }\n    }\n    return iterations;\n  };\n  zipSequence.__iteratorUncached = function(type, reverse) {\n    var iterators = iters.map(\n      function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }\n    );\n    var iterations = 0;\n    var isDone = false;\n    return new Iterator(function () {\n      var steps;\n      if (!isDone) {\n        steps = iterators.map(function (i) { return i.next(); });\n        isDone = steps.some(function (s) { return s.done; });\n      }\n      if (isDone) {\n        return iteratorDone();\n      }\n      return iteratorValue(\n        type,\n        iterations++,\n        zipper.apply(null, steps.map(function (s) { return s.value; }))\n      );\n    });\n  };\n  return zipSequence;\n}\n\n// #pragma Helper Functions\n\nfunction reify(iter, seq) {\n  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n}\n\nfunction validateEntry(entry) {\n  if (entry !== Object(entry)) {\n    throw new TypeError('Expected [K, V] tuple: ' + entry);\n  }\n}\n\nfunction collectionClass(collection) {\n  return isKeyed(collection)\n    ? KeyedCollection\n    : isIndexed(collection) ? IndexedCollection : SetCollection;\n}\n\nfunction makeSequence(collection) {\n  return Object.create(\n    (isKeyed(collection)\n      ? KeyedSeq\n      : isIndexed(collection) ? IndexedSeq : SetSeq).prototype\n  );\n}\n\nfunction cacheResultThrough() {\n  if (this._iter.cacheResult) {\n    this._iter.cacheResult();\n    this.size = this._iter.size;\n    return this;\n  }\n  return Seq.prototype.cacheResult.call(this);\n}\n\nfunction defaultComparator(a, b) {\n  if (a === undefined && b === undefined) {\n    return 0;\n  }\n\n  if (a === undefined) {\n    return 1;\n  }\n\n  if (b === undefined) {\n    return -1;\n  }\n\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\nfunction coerceKeyPath(keyPath) {\n  if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n    return keyPath;\n  }\n  if (isOrdered(keyPath)) {\n    return keyPath.toArray();\n  }\n  throw new TypeError(\n    'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath\n  );\n}\n\nfunction invariant(condition, error) {\n  if (!condition) { throw new Error(error); }\n}\n\nfunction assertNotInfinite(size) {\n  invariant(\n    size !== Infinity,\n    'Cannot perform this action with an infinite size.'\n  );\n}\n\n/**\n * Converts a value to a string, adding quotes if a string was provided.\n */\nfunction quoteString(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : String(value);\n}\n\nvar Map = (function (KeyedCollection$$1) {\n  function Map(value) {\n    return value === null || value === undefined\n      ? emptyMap()\n      : isMap(value) && !isOrdered(value)\n          ? value\n          : emptyMap().withMutations(function (map) {\n              var iter = KeyedCollection$$1(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v, k) { return map.set(k, v); });\n            });\n  }\n\n  if ( KeyedCollection$$1 ) Map.__proto__ = KeyedCollection$$1;\n  Map.prototype = Object.create( KeyedCollection$$1 && KeyedCollection$$1.prototype );\n  Map.prototype.constructor = Map;\n\n  Map.of = function of () {\n    var keyValues = [], len = arguments.length;\n    while ( len-- ) keyValues[ len ] = arguments[ len ];\n\n    return emptyMap().withMutations(function (map) {\n      for (var i = 0; i < keyValues.length; i += 2) {\n        if (i + 1 >= keyValues.length) {\n          throw new Error('Missing value for key: ' + keyValues[i]);\n        }\n        map.set(keyValues[i], keyValues[i + 1]);\n      }\n    });\n  };\n\n  Map.prototype.toString = function toString () {\n    return this.__toString('Map {', '}');\n  };\n\n  // @pragma Access\n\n  Map.prototype.get = function get (k, notSetValue) {\n    return this._root\n      ? this._root.get(0, undefined, k, notSetValue)\n      : notSetValue;\n  };\n\n  // @pragma Modification\n\n  Map.prototype.set = function set (k, v) {\n    return updateMap(this, k, v);\n  };\n\n  Map.prototype.setIn = function setIn (keyPath, v) {\n    return this.updateIn(keyPath, NOT_SET, function () { return v; });\n  };\n\n  Map.prototype.remove = function remove (k) {\n    return updateMap(this, k, NOT_SET);\n  };\n\n  Map.prototype.deleteIn = function deleteIn (keyPath) {\n    keyPath = [].concat( coerceKeyPath(keyPath) );\n    if (keyPath.length) {\n      var lastKey = keyPath.pop();\n      return this.updateIn(keyPath, function (c) { return c && c.remove(lastKey); });\n    }\n  };\n\n  Map.prototype.deleteAll = function deleteAll (keys) {\n    var collection = Collection(keys);\n\n    if (collection.size === 0) {\n      return this;\n    }\n\n    return this.withMutations(function (map) {\n      collection.forEach(function (key) { return map.remove(key); });\n    });\n  };\n\n  Map.prototype.update = function update (k, notSetValue, updater) {\n    return arguments.length === 1\n      ? k(this)\n      : this.updateIn([k], notSetValue, updater);\n  };\n\n  Map.prototype.updateIn = function updateIn (keyPath, notSetValue, updater) {\n    if (!updater) {\n      updater = notSetValue;\n      notSetValue = undefined;\n    }\n    var updatedValue = updateInDeepMap(\n      this,\n      coerceKeyPath(keyPath),\n      0,\n      notSetValue,\n      updater\n    );\n    return updatedValue === NOT_SET ? notSetValue : updatedValue;\n  };\n\n  Map.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._root = null;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyMap();\n  };\n\n  // @pragma Composition\n\n  Map.prototype.merge = function merge (/*...iters*/) {\n    return mergeIntoMapWith(this, undefined, arguments);\n  };\n\n  Map.prototype.mergeWith = function mergeWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoMapWith(this, merger, iters);\n  };\n\n  Map.prototype.mergeIn = function mergeIn (keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return this.updateIn(\n      keyPath,\n      emptyMap(),\n      function (m) { return typeof m.merge === 'function'\n          ? m.merge.apply(m, iters)\n          : iters[iters.length - 1]; }\n    );\n  };\n\n  Map.prototype.mergeDeep = function mergeDeep (/*...iters*/) {\n    return mergeIntoMapWith(this, deepMerger, arguments);\n  };\n\n  Map.prototype.mergeDeepWith = function mergeDeepWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n  };\n\n  Map.prototype.mergeDeepIn = function mergeDeepIn (keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return this.updateIn(\n      keyPath,\n      emptyMap(),\n      function (m) { return typeof m.mergeDeep === 'function'\n          ? m.mergeDeep.apply(m, iters)\n          : iters[iters.length - 1]; }\n    );\n  };\n\n  Map.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator));\n  };\n\n  Map.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator, mapper));\n  };\n\n  // @pragma Mutability\n\n  Map.prototype.withMutations = function withMutations (fn) {\n    var mutable = this.asMutable();\n    fn(mutable);\n    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n  };\n\n  Map.prototype.asMutable = function asMutable () {\n    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n  };\n\n  Map.prototype.asImmutable = function asImmutable () {\n    return this.__ensureOwner();\n  };\n\n  Map.prototype.wasAltered = function wasAltered () {\n    return this.__altered;\n  };\n\n  Map.prototype.__iterator = function __iterator (type, reverse) {\n    return new MapIterator(this, type, reverse);\n  };\n\n  Map.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    this._root &&\n      this._root.iterate(\n        function (entry) {\n          iterations++;\n          return fn(entry[1], entry[0], this$1);\n        },\n        reverse\n      );\n    return iterations;\n  };\n\n  Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyMap();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeMap(this.size, this._root, ownerID, this.__hash);\n  };\n\n  return Map;\n}(KeyedCollection));\n\nfunction isMap(maybeMap) {\n  return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n}\n\nMap.isMap = isMap;\n\nvar IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\nvar MapPrototype = Map.prototype;\nMapPrototype[IS_MAP_SENTINEL] = true;\nMapPrototype[DELETE] = MapPrototype.remove;\nMapPrototype.removeIn = MapPrototype.deleteIn;\nMapPrototype.removeAll = MapPrototype.deleteAll;\n\n// #pragma Trie Nodes\n\nvar ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n  this.ownerID = ownerID;\n  this.entries = entries;\n};\n\nArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && entries.length === 1) {\n    return; // undefined\n  }\n\n  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n    return createNodes(ownerID, entries, key, value);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new ArrayMapNode(ownerID, newEntries);\n};\n\nvar BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n  this.ownerID = ownerID;\n  this.bitmap = bitmap;\n  this.nodes = nodes;\n};\n\nBitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n  var bitmap = this.bitmap;\n  return (bitmap & bit) === 0\n    ? notSetValue\n    : this.nodes[popCount(bitmap & bit - 1)].get(\n        shift + SHIFT,\n        keyHash,\n        key,\n        notSetValue\n      );\n};\n\nBitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var bit = 1 << keyHashFrag;\n  var bitmap = this.bitmap;\n  var exists = (bitmap & bit) !== 0;\n\n  if (!exists && value === NOT_SET) {\n    return this;\n  }\n\n  var idx = popCount(bitmap & bit - 1);\n  var nodes = this.nodes;\n  var node = exists ? nodes[idx] : undefined;\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n\n  if (newNode === node) {\n    return this;\n  }\n\n  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n  }\n\n  if (\n    exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])\n  ) {\n    return nodes[idx ^ 1];\n  }\n\n  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n    return newNode;\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n  var newNodes = exists\n    ? newNode\n        ? setIn(nodes, idx, newNode, isEditable)\n        : spliceOut(nodes, idx, isEditable)\n    : spliceIn(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.bitmap = newBitmap;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n};\n\nvar HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n  this.ownerID = ownerID;\n  this.count = count;\n  this.nodes = nodes;\n};\n\nHashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var node = this.nodes[idx];\n  return node\n    ? node.get(shift + SHIFT, keyHash, key, notSetValue)\n    : notSetValue;\n};\n\nHashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var removed = value === NOT_SET;\n  var nodes = this.nodes;\n  var node = nodes[idx];\n\n  if (removed && !node) {\n    return this;\n  }\n\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n  if (newNode === node) {\n    return this;\n  }\n\n  var newCount = this.count;\n  if (!node) {\n    newCount++;\n  } else if (!newNode) {\n    newCount--;\n    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n      return packNodes(ownerID, nodes, newCount, idx);\n    }\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.count = newCount;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new HashArrayMapNode(ownerID, newCount, newNodes);\n};\n\nvar HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entries = entries;\n};\n\nHashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nHashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n\n  var removed = value === NOT_SET;\n\n  if (keyHash !== this.keyHash) {\n    if (removed) {\n      return this;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n  }\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && len === 2) {\n    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n};\n\nvar ValueNode = function ValueNode(ownerID, keyHash, entry) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entry = entry;\n};\n\nValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n};\n\nValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n  var keyMatch = is(key, this.entry[0]);\n  if (keyMatch ? value === this.entry[1] : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n\n  if (removed) {\n    SetRef(didChangeSize);\n    return; // undefined\n  }\n\n  if (keyMatch) {\n    if (ownerID && ownerID === this.ownerID) {\n      this.entry[1] = value;\n      return this;\n    }\n    return new ValueNode(ownerID, this.keyHash, [key, value]);\n  }\n\n  SetRef(didChangeSize);\n  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n};\n\n// #pragma Iterators\n\nArrayMapNode.prototype.iterate = (HashCollisionNode.prototype.iterate = function(\n  fn,\n  reverse\n) {\n  var entries = this.entries;\n  for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n    if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n      return false;\n    }\n  }\n});\n\nBitmapIndexedNode.prototype.iterate = (HashArrayMapNode.prototype.iterate = function(\n  fn,\n  reverse\n) {\n  var nodes = this.nodes;\n  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n    var node = nodes[reverse ? maxIndex - ii : ii];\n    if (node && node.iterate(fn, reverse) === false) {\n      return false;\n    }\n  }\n});\n\n// eslint-disable-next-line no-unused-vars\nValueNode.prototype.iterate = function(fn, reverse) {\n  return fn(this.entry);\n};\n\nvar MapIterator = (function (Iterator$$1) {\n  function MapIterator(map, type, reverse) {\n    this._type = type;\n    this._reverse = reverse;\n    this._stack = map._root && mapIteratorFrame(map._root);\n  }\n\n  if ( Iterator$$1 ) MapIterator.__proto__ = Iterator$$1;\n  MapIterator.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );\n  MapIterator.prototype.constructor = MapIterator;\n\n  MapIterator.prototype.next = function next () {\n    var this$1 = this;\n\n    var type = this._type;\n    var stack = this._stack;\n    while (stack) {\n      var node = stack.node;\n      var index = stack.index++;\n      var maxIndex = (void 0);\n      if (node.entry) {\n        if (index === 0) {\n          return mapIteratorValue(type, node.entry);\n        }\n      } else if (node.entries) {\n        maxIndex = node.entries.length - 1;\n        if (index <= maxIndex) {\n          return mapIteratorValue(\n            type,\n            node.entries[this$1._reverse ? maxIndex - index : index]\n          );\n        }\n      } else {\n        maxIndex = node.nodes.length - 1;\n        if (index <= maxIndex) {\n          var subNode = node.nodes[this$1._reverse ? maxIndex - index : index];\n          if (subNode) {\n            if (subNode.entry) {\n              return mapIteratorValue(type, subNode.entry);\n            }\n            stack = (this$1._stack = mapIteratorFrame(subNode, stack));\n          }\n          continue;\n        }\n      }\n      stack = (this$1._stack = this$1._stack.__prev);\n    }\n    return iteratorDone();\n  };\n\n  return MapIterator;\n}(Iterator));\n\nfunction mapIteratorValue(type, entry) {\n  return iteratorValue(type, entry[0], entry[1]);\n}\n\nfunction mapIteratorFrame(node, prev) {\n  return {\n    node: node,\n    index: 0,\n    __prev: prev\n  };\n}\n\nfunction makeMap(size, root, ownerID, hash$$1) {\n  var map = Object.create(MapPrototype);\n  map.size = size;\n  map._root = root;\n  map.__ownerID = ownerID;\n  map.__hash = hash$$1;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_MAP;\nfunction emptyMap() {\n  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n}\n\nfunction updateMap(map, k, v) {\n  var newRoot;\n  var newSize;\n  if (!map._root) {\n    if (v === NOT_SET) {\n      return map;\n    }\n    newSize = 1;\n    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n  } else {\n    var didChangeSize = MakeRef(CHANGE_LENGTH);\n    var didAlter = MakeRef(DID_ALTER);\n    newRoot = updateNode(\n      map._root,\n      map.__ownerID,\n      0,\n      undefined,\n      k,\n      v,\n      didChangeSize,\n      didAlter\n    );\n    if (!didAlter.value) {\n      return map;\n    }\n    newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n  }\n  if (map.__ownerID) {\n    map.size = newSize;\n    map._root = newRoot;\n    map.__hash = undefined;\n    map.__altered = true;\n    return map;\n  }\n  return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n}\n\nfunction updateNode(\n  node,\n  ownerID,\n  shift,\n  keyHash,\n  key,\n  value,\n  didChangeSize,\n  didAlter\n) {\n  if (!node) {\n    if (value === NOT_SET) {\n      return node;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return new ValueNode(ownerID, keyHash, [key, value]);\n  }\n  return node.update(\n    ownerID,\n    shift,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n}\n\nfunction isLeafNode(node) {\n  return node.constructor === ValueNode ||\n    node.constructor === HashCollisionNode;\n}\n\nfunction mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n  if (node.keyHash === keyHash) {\n    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n  }\n\n  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n  var newNode;\n  var nodes = idx1 === idx2\n    ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n    : ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2\n        ? [node, newNode]\n        : [newNode, node]);\n\n  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);\n}\n\nfunction createNodes(ownerID, entries, key, value) {\n  if (!ownerID) {\n    ownerID = new OwnerID();\n  }\n  var node = new ValueNode(ownerID, hash(key), [key, value]);\n  for (var ii = 0; ii < entries.length; ii++) {\n    var entry = entries[ii];\n    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n  }\n  return node;\n}\n\nfunction packNodes(ownerID, nodes, count, excluding) {\n  var bitmap = 0;\n  var packedII = 0;\n  var packedNodes = new Array(count);\n  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, (bit <<= 1)) {\n    var node = nodes[ii];\n    if (node !== undefined && ii !== excluding) {\n      bitmap |= bit;\n      packedNodes[packedII++] = node;\n    }\n  }\n  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n}\n\nfunction expandNodes(ownerID, nodes, bitmap, including, node) {\n  var count = 0;\n  var expandedNodes = new Array(SIZE);\n  for (var ii = 0; bitmap !== 0; ii++, (bitmap >>>= 1)) {\n    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n  }\n  expandedNodes[including] = node;\n  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n}\n\nfunction mergeIntoMapWith(map, merger, collections) {\n  var iters = [];\n  for (var ii = 0; ii < collections.length; ii++) {\n    var value = collections[ii];\n    var iter = KeyedCollection(value);\n    if (!isCollection(value)) {\n      iter = iter.map(function (v) { return fromJS(v); });\n    }\n    iters.push(iter);\n  }\n  return mergeIntoCollectionWith(map, merger, iters);\n}\n\nfunction deepMerger(oldVal, newVal) {\n  return oldVal && oldVal.mergeDeep && isCollection(newVal)\n    ? oldVal.mergeDeep(newVal)\n    : is(oldVal, newVal) ? oldVal : newVal;\n}\n\nfunction deepMergerWith(merger) {\n  return function (oldVal, newVal, key) {\n    if (oldVal && oldVal.mergeDeepWith && isCollection(newVal)) {\n      return oldVal.mergeDeepWith(merger, newVal);\n    }\n    var nextValue = merger(oldVal, newVal, key);\n    return is(oldVal, nextValue) ? oldVal : nextValue;\n  };\n}\n\nfunction mergeIntoCollectionWith(collection, merger, iters) {\n  iters = iters.filter(function (x) { return x.size !== 0; });\n  if (iters.length === 0) {\n    return collection;\n  }\n  if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n    return collection.constructor(iters[0]);\n  }\n  return collection.withMutations(function (collection) {\n    var mergeIntoMap = merger\n      ? function (value, key) {\n          collection.update(\n            key,\n            NOT_SET,\n            function (oldVal) { return oldVal === NOT_SET ? value : merger(oldVal, value, key); }\n          );\n        }\n      : function (value, key) {\n          collection.set(key, value);\n        };\n    for (var ii = 0; ii < iters.length; ii++) {\n      iters[ii].forEach(mergeIntoMap);\n    }\n  });\n}\n\nfunction updateInDeepMap(existing, keyPath, i, notSetValue, updater) {\n  var isNotSet = existing === NOT_SET;\n  if (i === keyPath.length) {\n    var existingValue = isNotSet ? notSetValue : existing;\n    var newValue = updater(existingValue);\n    return newValue === existingValue ? existing : newValue;\n  }\n  if (!(isNotSet || (existing && existing.set))) {\n    throw new TypeError(\n      'Invalid keyPath: Value at [' +\n        keyPath.slice(0, i).map(quoteString) +\n        '] does not have a .set() method and cannot be updated: ' +\n        existing\n    );\n  }\n  var key = keyPath[i];\n  var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n  var nextUpdated = updateInDeepMap(\n    nextExisting,\n    keyPath,\n    i + 1,\n    notSetValue,\n    updater\n  );\n  return nextUpdated === nextExisting\n    ? existing\n    : nextUpdated === NOT_SET\n        ? existing.remove(key)\n        : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n}\n\nfunction popCount(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n\nfunction setIn(array, idx, val, canEdit) {\n  var newArray = canEdit ? array : arrCopy(array);\n  newArray[idx] = val;\n  return newArray;\n}\n\nfunction spliceIn(array, idx, val, canEdit) {\n  var newLen = array.length + 1;\n  if (canEdit && idx + 1 === newLen) {\n    array[idx] = val;\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      newArray[ii] = val;\n      after = -1;\n    } else {\n      newArray[ii] = array[ii + after];\n    }\n  }\n  return newArray;\n}\n\nfunction spliceOut(array, idx, canEdit) {\n  var newLen = array.length - 1;\n  if (canEdit && idx === newLen) {\n    array.pop();\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      after = 1;\n    }\n    newArray[ii] = array[ii + after];\n  }\n  return newArray;\n}\n\nvar MAX_ARRAY_MAP_SIZE = SIZE / 4;\nvar MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\nvar MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\nvar List = (function (IndexedCollection$$1) {\n  function List(value) {\n    var empty = emptyList();\n    if (value === null || value === undefined) {\n      return empty;\n    }\n    if (isList(value)) {\n      return value;\n    }\n    var iter = IndexedCollection$$1(value);\n    var size = iter.size;\n    if (size === 0) {\n      return empty;\n    }\n    assertNotInfinite(size);\n    if (size > 0 && size < SIZE) {\n      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n    }\n    return empty.withMutations(function (list) {\n      list.setSize(size);\n      iter.forEach(function (v, i) { return list.set(i, v); });\n    });\n  }\n\n  if ( IndexedCollection$$1 ) List.__proto__ = IndexedCollection$$1;\n  List.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );\n  List.prototype.constructor = List;\n\n  List.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  List.prototype.toString = function toString () {\n    return this.__toString('List [', ']');\n  };\n\n  // @pragma Access\n\n  List.prototype.get = function get (index, notSetValue) {\n    index = wrapIndex(this, index);\n    if (index >= 0 && index < this.size) {\n      index += this._origin;\n      var node = listNodeFor(this, index);\n      return node && node.array[index & MASK];\n    }\n    return notSetValue;\n  };\n\n  // @pragma Modification\n\n  List.prototype.set = function set (index, value) {\n    return updateList(this, index, value);\n  };\n\n  List.prototype.remove = function remove (index) {\n    return !this.has(index)\n      ? this\n      : index === 0\n          ? this.shift()\n          : index === this.size - 1 ? this.pop() : this.splice(index, 1);\n  };\n\n  List.prototype.insert = function insert (index, value) {\n    return this.splice(index, 0, value);\n  };\n\n  List.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = (this._origin = (this._capacity = 0));\n      this._level = SHIFT;\n      this._root = (this._tail = null);\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyList();\n  };\n\n  List.prototype.push = function push (/*...values*/) {\n    var values = arguments;\n    var oldSize = this.size;\n    return this.withMutations(function (list) {\n      setListBounds(list, 0, oldSize + values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(oldSize + ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.pop = function pop () {\n    return setListBounds(this, 0, -1);\n  };\n\n  List.prototype.unshift = function unshift (/*...values*/) {\n    var values = arguments;\n    return this.withMutations(function (list) {\n      setListBounds(list, -values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.shift = function shift () {\n    return setListBounds(this, 1);\n  };\n\n  // @pragma Composition\n\n  List.prototype.merge = function merge (/*...iters*/) {\n    return mergeIntoListWith(this, undefined, arguments);\n  };\n\n  List.prototype.mergeWith = function mergeWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoListWith(this, merger, iters);\n  };\n\n  List.prototype.mergeDeep = function mergeDeep (/*...iters*/) {\n    return mergeIntoListWith(this, deepMerger, arguments);\n  };\n\n  List.prototype.mergeDeepWith = function mergeDeepWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoListWith(this, deepMergerWith(merger), iters);\n  };\n\n  List.prototype.setSize = function setSize (size) {\n    return setListBounds(this, 0, size);\n  };\n\n  // @pragma Iteration\n\n  List.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    if (wholeSlice(begin, end, size)) {\n      return this;\n    }\n    return setListBounds(\n      this,\n      resolveBegin(begin, size),\n      resolveEnd(end, size)\n    );\n  };\n\n  List.prototype.__iterator = function __iterator (type, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    return new Iterator(function () {\n      var value = values();\n      return value === DONE\n        ? iteratorDone()\n        : iteratorValue(type, reverse ? --index : index++, value);\n    });\n  };\n\n  List.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    var value;\n    while ((value = values()) !== DONE) {\n      if (fn(value, reverse ? --index : index++, this$1) === false) {\n        break;\n      }\n    }\n    return index;\n  };\n\n  List.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyList();\n      }\n      this.__ownerID = ownerID;\n      return this;\n    }\n    return makeList(\n      this._origin,\n      this._capacity,\n      this._level,\n      this._root,\n      this._tail,\n      ownerID,\n      this.__hash\n    );\n  };\n\n  return List;\n}(IndexedCollection));\n\nfunction isList(maybeList) {\n  return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n}\n\nList.isList = isList;\n\nvar IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\nvar ListPrototype = List.prototype;\nListPrototype[IS_LIST_SENTINEL] = true;\nListPrototype[DELETE] = ListPrototype.remove;\nListPrototype.setIn = MapPrototype.setIn;\nListPrototype.deleteIn = (ListPrototype.removeIn = MapPrototype.removeIn);\nListPrototype.update = MapPrototype.update;\nListPrototype.updateIn = MapPrototype.updateIn;\nListPrototype.mergeIn = MapPrototype.mergeIn;\nListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\nListPrototype.withMutations = MapPrototype.withMutations;\nListPrototype.asMutable = MapPrototype.asMutable;\nListPrototype.asImmutable = MapPrototype.asImmutable;\nListPrototype.wasAltered = MapPrototype.wasAltered;\n\nvar VNode = function VNode(array, ownerID) {\n  this.array = array;\n  this.ownerID = ownerID;\n};\n\n// TODO: seems like these methods are very similar\n\nVNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {\n  if (index === level ? 1 << level : 0 || this.array.length === 0) {\n    return this;\n  }\n  var originIndex = index >>> level & MASK;\n  if (originIndex >= this.array.length) {\n    return new VNode([], ownerID);\n  }\n  var removingFirst = originIndex === 0;\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[originIndex];\n    newChild = oldChild &&\n      oldChild.removeBefore(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && removingFirst) {\n      return this;\n    }\n  }\n  if (removingFirst && !newChild) {\n    return this;\n  }\n  var editable = editableVNode(this, ownerID);\n  if (!removingFirst) {\n    for (var ii = 0; ii < originIndex; ii++) {\n      editable.array[ii] = undefined;\n    }\n  }\n  if (newChild) {\n    editable.array[originIndex] = newChild;\n  }\n  return editable;\n};\n\nVNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {\n  if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n    return this;\n  }\n  var sizeIndex = index - 1 >>> level & MASK;\n  if (sizeIndex >= this.array.length) {\n    return this;\n  }\n\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[sizeIndex];\n    newChild = oldChild &&\n      oldChild.removeAfter(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n      return this;\n    }\n  }\n\n  var editable = editableVNode(this, ownerID);\n  editable.array.splice(sizeIndex + 1);\n  if (newChild) {\n    editable.array[sizeIndex] = newChild;\n  }\n  return editable;\n};\n\nvar DONE = {};\n\nfunction iterateList(list, reverse) {\n  var left = list._origin;\n  var right = list._capacity;\n  var tailPos = getTailOffset(right);\n  var tail = list._tail;\n\n  return iterateNodeOrLeaf(list._root, list._level, 0);\n\n  function iterateNodeOrLeaf(node, level, offset) {\n    return level === 0\n      ? iterateLeaf(node, offset)\n      : iterateNode(node, level, offset);\n  }\n\n  function iterateLeaf(node, offset) {\n    var array = offset === tailPos ? tail && tail.array : node && node.array;\n    var from = offset > left ? 0 : left - offset;\n    var to = right - offset;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      if (from === to) {\n        return DONE;\n      }\n      var idx = reverse ? --to : from++;\n      return array && array[idx];\n    };\n  }\n\n  function iterateNode(node, level, offset) {\n    var values;\n    var array = node && node.array;\n    var from = offset > left ? 0 : left - offset >> level;\n    var to = (right - offset >> level) + 1;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      while (true) {\n        if (values) {\n          var value = values();\n          if (value !== DONE) {\n            return value;\n          }\n          values = null;\n        }\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        values = iterateNodeOrLeaf(\n          array && array[idx],\n          level - SHIFT,\n          offset + (idx << level)\n        );\n      }\n    };\n  }\n}\n\nfunction makeList(origin, capacity, level, root, tail, ownerID, hash) {\n  var list = Object.create(ListPrototype);\n  list.size = capacity - origin;\n  list._origin = origin;\n  list._capacity = capacity;\n  list._level = level;\n  list._root = root;\n  list._tail = tail;\n  list.__ownerID = ownerID;\n  list.__hash = hash;\n  list.__altered = false;\n  return list;\n}\n\nvar EMPTY_LIST;\nfunction emptyList() {\n  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n}\n\nfunction updateList(list, index, value) {\n  index = wrapIndex(list, index);\n\n  if (index !== index) {\n    return list;\n  }\n\n  if (index >= list.size || index < 0) {\n    return list.withMutations(function (list) {\n      index < 0\n        ? setListBounds(list, index).set(0, value)\n        : setListBounds(list, 0, index + 1).set(index, value);\n    });\n  }\n\n  index += list._origin;\n\n  var newTail = list._tail;\n  var newRoot = list._root;\n  var didAlter = MakeRef(DID_ALTER);\n  if (index >= getTailOffset(list._capacity)) {\n    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n  } else {\n    newRoot = updateVNode(\n      newRoot,\n      list.__ownerID,\n      list._level,\n      index,\n      value,\n      didAlter\n    );\n  }\n\n  if (!didAlter.value) {\n    return list;\n  }\n\n  if (list.__ownerID) {\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\n\nfunction updateVNode(node, ownerID, level, index, value, didAlter) {\n  var idx = index >>> level & MASK;\n  var nodeHas = node && idx < node.array.length;\n  if (!nodeHas && value === undefined) {\n    return node;\n  }\n\n  var newNode;\n\n  if (level > 0) {\n    var lowerNode = node && node.array[idx];\n    var newLowerNode = updateVNode(\n      lowerNode,\n      ownerID,\n      level - SHIFT,\n      index,\n      value,\n      didAlter\n    );\n    if (newLowerNode === lowerNode) {\n      return node;\n    }\n    newNode = editableVNode(node, ownerID);\n    newNode.array[idx] = newLowerNode;\n    return newNode;\n  }\n\n  if (nodeHas && node.array[idx] === value) {\n    return node;\n  }\n\n  SetRef(didAlter);\n\n  newNode = editableVNode(node, ownerID);\n  if (value === undefined && idx === newNode.array.length - 1) {\n    newNode.array.pop();\n  } else {\n    newNode.array[idx] = value;\n  }\n  return newNode;\n}\n\nfunction editableVNode(node, ownerID) {\n  if (ownerID && node && ownerID === node.ownerID) {\n    return node;\n  }\n  return new VNode(node ? node.array.slice() : [], ownerID);\n}\n\nfunction listNodeFor(list, rawIndex) {\n  if (rawIndex >= getTailOffset(list._capacity)) {\n    return list._tail;\n  }\n  if (rawIndex < 1 << list._level + SHIFT) {\n    var node = list._root;\n    var level = list._level;\n    while (node && level > 0) {\n      node = node.array[rawIndex >>> level & MASK];\n      level -= SHIFT;\n    }\n    return node;\n  }\n}\n\nfunction setListBounds(list, begin, end) {\n  // Sanitize begin & end using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  if (begin !== undefined) {\n    begin |= 0;\n  }\n  if (end !== undefined) {\n    end |= 0;\n  }\n  var owner = list.__ownerID || new OwnerID();\n  var oldOrigin = list._origin;\n  var oldCapacity = list._capacity;\n  var newOrigin = oldOrigin + begin;\n  var newCapacity = end === undefined\n    ? oldCapacity\n    : end < 0 ? oldCapacity + end : oldOrigin + end;\n  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n    return list;\n  }\n\n  // If it's going to end after it starts, it's empty.\n  if (newOrigin >= newCapacity) {\n    return list.clear();\n  }\n\n  var newLevel = list._level;\n  var newRoot = list._root;\n\n  // New origin might need creating a higher root.\n  var offsetShift = 0;\n  while (newOrigin + offsetShift < 0) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [undefined, newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n    offsetShift += 1 << newLevel;\n  }\n  if (offsetShift) {\n    newOrigin += offsetShift;\n    oldOrigin += offsetShift;\n    newCapacity += offsetShift;\n    oldCapacity += offsetShift;\n  }\n\n  var oldTailOffset = getTailOffset(oldCapacity);\n  var newTailOffset = getTailOffset(newCapacity);\n\n  // New size might need creating a higher root.\n  while (newTailOffset >= 1 << newLevel + SHIFT) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n  }\n\n  // Locate or create the new tail.\n  var oldTail = list._tail;\n  var newTail = newTailOffset < oldTailOffset\n    ? listNodeFor(list, newCapacity - 1)\n    : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n  // Merge Tail into tree.\n  if (\n    oldTail &&\n    newTailOffset > oldTailOffset &&\n    newOrigin < oldCapacity &&\n    oldTail.array.length\n  ) {\n    newRoot = editableVNode(newRoot, owner);\n    var node = newRoot;\n    for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n      var idx = oldTailOffset >>> level & MASK;\n      node = (node.array[idx] = editableVNode(node.array[idx], owner));\n    }\n    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;\n  }\n\n  // If the size has been reduced, there's a chance the tail needs to be trimmed.\n  if (newCapacity < oldCapacity) {\n    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n  }\n\n  // If the new origin is within the tail, then we do not need a root.\n  if (newOrigin >= newTailOffset) {\n    newOrigin -= newTailOffset;\n    newCapacity -= newTailOffset;\n    newLevel = SHIFT;\n    newRoot = null;\n    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n    offsetShift = 0;\n\n    // Identify the new top root node of the subtree of the old root.\n    while (newRoot) {\n      var beginIndex = newOrigin >>> newLevel & MASK;\n      if (beginIndex !== newTailOffset >>> newLevel & MASK) {\n        break;\n      }\n      if (beginIndex) {\n        offsetShift += (1 << newLevel) * beginIndex;\n      }\n      newLevel -= SHIFT;\n      newRoot = newRoot.array[beginIndex];\n    }\n\n    // Trim the new sides of the new root.\n    if (newRoot && newOrigin > oldOrigin) {\n      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n    }\n    if (newRoot && newTailOffset < oldTailOffset) {\n      newRoot = newRoot.removeAfter(\n        owner,\n        newLevel,\n        newTailOffset - offsetShift\n      );\n    }\n    if (offsetShift) {\n      newOrigin -= offsetShift;\n      newCapacity -= offsetShift;\n    }\n  }\n\n  if (list.__ownerID) {\n    list.size = newCapacity - newOrigin;\n    list._origin = newOrigin;\n    list._capacity = newCapacity;\n    list._level = newLevel;\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n}\n\nfunction mergeIntoListWith(list, merger, collections) {\n  var iters = [];\n  var maxSize = 0;\n  for (var ii = 0; ii < collections.length; ii++) {\n    var value = collections[ii];\n    var iter = IndexedCollection(value);\n    if (iter.size > maxSize) {\n      maxSize = iter.size;\n    }\n    if (!isCollection(value)) {\n      iter = iter.map(function (v) { return fromJS(v); });\n    }\n    iters.push(iter);\n  }\n  if (maxSize > list.size) {\n    list = list.setSize(maxSize);\n  }\n  return mergeIntoCollectionWith(list, merger, iters);\n}\n\nfunction getTailOffset(size) {\n  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;\n}\n\nvar OrderedMap = (function (Map$$1) {\n  function OrderedMap(value) {\n    return value === null || value === undefined\n      ? emptyOrderedMap()\n      : isOrderedMap(value)\n          ? value\n          : emptyOrderedMap().withMutations(function (map) {\n              var iter = KeyedCollection(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v, k) { return map.set(k, v); });\n            });\n  }\n\n  if ( Map$$1 ) OrderedMap.__proto__ = Map$$1;\n  OrderedMap.prototype = Object.create( Map$$1 && Map$$1.prototype );\n  OrderedMap.prototype.constructor = OrderedMap;\n\n  OrderedMap.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedMap.prototype.toString = function toString () {\n    return this.__toString('OrderedMap {', '}');\n  };\n\n  // @pragma Access\n\n  OrderedMap.prototype.get = function get (k, notSetValue) {\n    var index = this._map.get(k);\n    return index !== undefined ? this._list.get(index)[1] : notSetValue;\n  };\n\n  // @pragma Modification\n\n  OrderedMap.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._map.clear();\n      this._list.clear();\n      return this;\n    }\n    return emptyOrderedMap();\n  };\n\n  OrderedMap.prototype.set = function set (k, v) {\n    return updateOrderedMap(this, k, v);\n  };\n\n  OrderedMap.prototype.remove = function remove (k) {\n    return updateOrderedMap(this, k, NOT_SET);\n  };\n\n  OrderedMap.prototype.wasAltered = function wasAltered () {\n    return this._map.wasAltered() || this._list.wasAltered();\n  };\n\n  OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._list.__iterate(\n      function (entry) { return entry && fn(entry[1], entry[0], this$1); },\n      reverse\n    );\n  };\n\n  OrderedMap.prototype.__iterator = function __iterator (type, reverse) {\n    return this._list.fromEntrySeq().__iterator(type, reverse);\n  };\n\n  OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    var newList = this._list.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyOrderedMap();\n      }\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      this._list = newList;\n      return this;\n    }\n    return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n  };\n\n  return OrderedMap;\n}(Map));\n\nfunction isOrderedMap(maybeOrderedMap) {\n  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n}\n\nOrderedMap.isOrderedMap = isOrderedMap;\n\nOrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\nOrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\nfunction makeOrderedMap(map, list, ownerID, hash) {\n  var omap = Object.create(OrderedMap.prototype);\n  omap.size = map ? map.size : 0;\n  omap._map = map;\n  omap._list = list;\n  omap.__ownerID = ownerID;\n  omap.__hash = hash;\n  return omap;\n}\n\nvar EMPTY_ORDERED_MAP;\nfunction emptyOrderedMap() {\n  return EMPTY_ORDERED_MAP ||\n    (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n}\n\nfunction updateOrderedMap(omap, k, v) {\n  var map = omap._map;\n  var list = omap._list;\n  var i = map.get(k);\n  var has = i !== undefined;\n  var newMap;\n  var newList;\n  if (v === NOT_SET) {\n    // removed\n    if (!has) {\n      return omap;\n    }\n    if (list.size >= SIZE && list.size >= map.size * 2) {\n      newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });\n      newMap = newList.toKeyedSeq().map(function (entry) { return entry[0]; }).flip().toMap();\n      if (omap.__ownerID) {\n        newMap.__ownerID = (newList.__ownerID = omap.__ownerID);\n      }\n    } else {\n      newMap = map.remove(k);\n      newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n    }\n  } else if (has) {\n    if (v === list.get(i)[1]) {\n      return omap;\n    }\n    newMap = map;\n    newList = list.set(i, [k, v]);\n  } else {\n    newMap = map.set(k, list.size);\n    newList = list.set(list.size, [k, v]);\n  }\n  if (omap.__ownerID) {\n    omap.size = newMap.size;\n    omap._map = newMap;\n    omap._list = newList;\n    omap.__hash = undefined;\n    return omap;\n  }\n  return makeOrderedMap(newMap, newList);\n}\n\nvar Stack = (function (IndexedCollection$$1) {\n  function Stack(value) {\n    return value === null || value === undefined\n      ? emptyStack()\n      : isStack(value) ? value : emptyStack().pushAll(value);\n  }\n\n  if ( IndexedCollection$$1 ) Stack.__proto__ = IndexedCollection$$1;\n  Stack.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );\n  Stack.prototype.constructor = Stack;\n\n  Stack.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Stack.prototype.toString = function toString () {\n    return this.__toString('Stack [', ']');\n  };\n\n  // @pragma Access\n\n  Stack.prototype.get = function get (index, notSetValue) {\n    var head = this._head;\n    index = wrapIndex(this, index);\n    while (head && index--) {\n      head = head.next;\n    }\n    return head ? head.value : notSetValue;\n  };\n\n  Stack.prototype.peek = function peek () {\n    return this._head && this._head.value;\n  };\n\n  // @pragma Modification\n\n  Stack.prototype.push = function push (/*...values*/) {\n    var arguments$1 = arguments;\n\n    if (arguments.length === 0) {\n      return this;\n    }\n    var newSize = this.size + arguments.length;\n    var head = this._head;\n    for (var ii = arguments.length - 1; ii >= 0; ii--) {\n      head = {\n        value: arguments$1[ii],\n        next: head\n      };\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pushAll = function pushAll (iter) {\n    iter = IndexedCollection$$1(iter);\n    if (iter.size === 0) {\n      return this;\n    }\n    if (this.size === 0 && isStack(iter)) {\n      return iter;\n    }\n    assertNotInfinite(iter.size);\n    var newSize = this.size;\n    var head = this._head;\n    iter.__iterate(\n      function (value) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      },\n      /* reverse */ true\n    );\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pop = function pop () {\n    return this.slice(1);\n  };\n\n  Stack.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._head = undefined;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyStack();\n  };\n\n  Stack.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    var resolvedBegin = resolveBegin(begin, this.size);\n    var resolvedEnd = resolveEnd(end, this.size);\n    if (resolvedEnd !== this.size) {\n      // super.slice(begin, end);\n      return IndexedCollection$$1.prototype.slice.call(this, begin, end);\n    }\n    var newSize = this.size - resolvedBegin;\n    var head = this._head;\n    while (resolvedBegin--) {\n      head = head.next;\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  // @pragma Mutability\n\n  Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyStack();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeStack(this.size, this._head, ownerID, this.__hash);\n  };\n\n  // @pragma Iteration\n\n  Stack.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterate(\n        function (v, k) { return fn(v, k, this$1); },\n        reverse\n      );\n    }\n    var iterations = 0;\n    var node = this._head;\n    while (node) {\n      if (fn(node.value, iterations++, this$1) === false) {\n        break;\n      }\n      node = node.next;\n    }\n    return iterations;\n  };\n\n  Stack.prototype.__iterator = function __iterator (type, reverse) {\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterator(type, reverse);\n    }\n    var iterations = 0;\n    var node = this._head;\n    return new Iterator(function () {\n      if (node) {\n        var value = node.value;\n        node = node.next;\n        return iteratorValue(type, iterations++, value);\n      }\n      return iteratorDone();\n    });\n  };\n\n  return Stack;\n}(IndexedCollection));\n\nfunction isStack(maybeStack) {\n  return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n}\n\nStack.isStack = isStack;\n\nvar IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\nvar StackPrototype = Stack.prototype;\nStackPrototype[IS_STACK_SENTINEL] = true;\nStackPrototype.withMutations = MapPrototype.withMutations;\nStackPrototype.asMutable = MapPrototype.asMutable;\nStackPrototype.asImmutable = MapPrototype.asImmutable;\nStackPrototype.wasAltered = MapPrototype.wasAltered;\nStackPrototype.shift = StackPrototype.pop;\nStackPrototype.unshift = StackPrototype.push;\nStackPrototype.unshiftAll = StackPrototype.pushAll;\n\nfunction makeStack(size, head, ownerID, hash) {\n  var map = Object.create(StackPrototype);\n  map.size = size;\n  map._head = head;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_STACK;\nfunction emptyStack() {\n  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n}\n\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (\n    !isCollection(b) ||\n    (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||\n    (a.__hash !== undefined &&\n      b.__hash !== undefined &&\n      a.__hash !== b.__hash) ||\n    isKeyed(a) !== isKeyed(b) ||\n    isIndexed(a) !== isIndexed(b) ||\n    isOrdered(a) !== isOrdered(b)\n  ) {\n    return false;\n  }\n\n  if (a.size === 0 && b.size === 0) {\n    return true;\n  }\n\n  var notAssociative = !isAssociative(a);\n\n  if (isOrdered(a)) {\n    var entries = a.entries();\n    return b.every(function (v, k) {\n      var entry = entries.next().value;\n      return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n    }) && entries.next().done;\n  }\n\n  var flipped = false;\n\n  if (a.size === undefined) {\n    if (b.size === undefined) {\n      if (typeof a.cacheResult === 'function') {\n        a.cacheResult();\n      }\n    } else {\n      flipped = true;\n      var _ = a;\n      a = b;\n      b = _;\n    }\n  }\n\n  var allEqual = true;\n  var bSize = b.__iterate(function (v, k) {\n    if (\n      notAssociative\n        ? !a.has(v)\n        : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)\n    ) {\n      allEqual = false;\n      return false;\n    }\n  });\n\n  return allEqual && a.size === bSize;\n}\n\n/**\n * Contributes additional methods to a constructor\n */\nfunction mixin(ctor, methods) {\n  var keyCopier = function (key) {\n    ctor.prototype[key] = methods[key];\n  };\n  Object.keys(methods).forEach(keyCopier);\n  Object.getOwnPropertySymbols &&\n    Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n  return ctor;\n}\n\nvar Set = (function (SetCollection$$1) {\n  function Set(value) {\n    return value === null || value === undefined\n      ? emptySet()\n      : isSet(value) && !isOrdered(value)\n          ? value\n          : emptySet().withMutations(function (set) {\n              var iter = SetCollection$$1(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v) { return set.add(v); });\n            });\n  }\n\n  if ( SetCollection$$1 ) Set.__proto__ = SetCollection$$1;\n  Set.prototype = Object.create( SetCollection$$1 && SetCollection$$1.prototype );\n  Set.prototype.constructor = Set;\n\n  Set.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Set.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  Set.intersect = function intersect (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.intersect.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.union = function union (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.union.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.prototype.toString = function toString () {\n    return this.__toString('Set {', '}');\n  };\n\n  // @pragma Access\n\n  Set.prototype.has = function has (value) {\n    return this._map.has(value);\n  };\n\n  // @pragma Modification\n\n  Set.prototype.add = function add (value) {\n    return updateSet(this, this._map.set(value, true));\n  };\n\n  Set.prototype.remove = function remove (value) {\n    return updateSet(this, this._map.remove(value));\n  };\n\n  Set.prototype.clear = function clear () {\n    return updateSet(this, this._map.clear());\n  };\n\n  // @pragma Composition\n\n  Set.prototype.union = function union () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    iters = iters.filter(function (x) { return x.size !== 0; });\n    if (iters.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n      return this.constructor(iters[0]);\n    }\n    return this.withMutations(function (set) {\n      for (var ii = 0; ii < iters.length; ii++) {\n        SetCollection$$1(iters[ii]).forEach(function (value) { return set.add(value); });\n      }\n    });\n  };\n\n  Set.prototype.intersect = function intersect () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    iters = iters.map(function (iter) { return SetCollection$$1(iter); });\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (!iters.every(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.subtract = function subtract () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (iters.some(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.merge = function merge () {\n    return this.union.apply(this, arguments);\n  };\n\n  Set.prototype.mergeWith = function mergeWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return this.union.apply(this, iters);\n  };\n\n  Set.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator));\n  };\n\n  Set.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator, mapper));\n  };\n\n  Set.prototype.wasAltered = function wasAltered () {\n    return this._map.wasAltered();\n  };\n\n  Set.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._map.__iterate(function (_, k) { return fn(k, k, this$1); }, reverse);\n  };\n\n  Set.prototype.__iterator = function __iterator (type, reverse) {\n    return this._map.map(function (_, k) { return k; }).__iterator(type, reverse);\n  };\n\n  Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptySet();\n      }\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      return this;\n    }\n    return this.__make(newMap, ownerID);\n  };\n\n  return Set;\n}(SetCollection));\n\nfunction isSet(maybeSet) {\n  return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n}\n\nSet.isSet = isSet;\n\nvar IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\nvar SetPrototype = Set.prototype;\nSetPrototype[IS_SET_SENTINEL] = true;\nSetPrototype[DELETE] = SetPrototype.remove;\nSetPrototype.mergeDeep = SetPrototype.merge;\nSetPrototype.mergeDeepWith = SetPrototype.mergeWith;\nSetPrototype.withMutations = MapPrototype.withMutations;\nSetPrototype.asMutable = MapPrototype.asMutable;\nSetPrototype.asImmutable = MapPrototype.asImmutable;\n\nSetPrototype.__empty = emptySet;\nSetPrototype.__make = makeSet;\n\nfunction updateSet(set, newMap) {\n  if (set.__ownerID) {\n    set.size = newMap.size;\n    set._map = newMap;\n    return set;\n  }\n  return newMap === set._map\n    ? set\n    : newMap.size === 0 ? set.__empty() : set.__make(newMap);\n}\n\nfunction makeSet(map, ownerID) {\n  var set = Object.create(SetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_SET;\nfunction emptySet() {\n  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n}\n\n/**\n * Returns a lazy seq of nums from start (inclusive) to end\n * (exclusive), by step, where start defaults to 0, step to 1, and end to\n * infinity. When start is equal to end, returns empty list.\n */\nvar Range = (function (IndexedSeq$$1) {\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      return new Range(start, end, step);\n    }\n    invariant(step !== 0, 'Cannot step a Range by 0');\n    start = start || 0;\n    if (end === undefined) {\n      end = Infinity;\n    }\n    step = step === undefined ? 1 : Math.abs(step);\n    if (end < start) {\n      step = -step;\n    }\n    this._start = start;\n    this._end = end;\n    this._step = step;\n    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n    if (this.size === 0) {\n      if (EMPTY_RANGE) {\n        return EMPTY_RANGE;\n      }\n      EMPTY_RANGE = this;\n    }\n  }\n\n  if ( IndexedSeq$$1 ) Range.__proto__ = IndexedSeq$$1;\n  Range.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  Range.prototype.constructor = Range;\n\n  Range.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Range []';\n    }\n    return 'Range [ ' +\n      this._start +\n      '...' +\n      this._end +\n      (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n  };\n\n  Range.prototype.get = function get (index, notSetValue) {\n    return this.has(index)\n      ? this._start + wrapIndex(this, index) * this._step\n      : notSetValue;\n  };\n\n  Range.prototype.includes = function includes (searchValue) {\n    var possibleIndex = (searchValue - this._start) / this._step;\n    return possibleIndex >= 0 &&\n      possibleIndex < this.size &&\n      possibleIndex === Math.floor(possibleIndex);\n  };\n\n  Range.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    begin = resolveBegin(begin, this.size);\n    end = resolveEnd(end, this.size);\n    if (end <= begin) {\n      return new Range(0, 0);\n    }\n    return new Range(\n      this.get(begin, this._end),\n      this.get(end, this._end),\n      this._step\n    );\n  };\n\n  Range.prototype.indexOf = function indexOf (searchValue) {\n    var offsetValue = searchValue - this._start;\n    if (offsetValue % this._step === 0) {\n      var index = offsetValue / this._step;\n      if (index >= 0 && index < this.size) {\n        return index;\n      }\n    }\n    return -1;\n  };\n\n  Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    return this.indexOf(searchValue);\n  };\n\n  Range.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    while (i !== size) {\n      if (fn(value, reverse ? size - ++i : i++, this$1) === false) {\n        break;\n      }\n      value += reverse ? -step : step;\n    }\n    return i;\n  };\n\n  Range.prototype.__iterator = function __iterator (type, reverse) {\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var v = value;\n      value += reverse ? -step : step;\n      return iteratorValue(type, reverse ? size - ++i : i++, v);\n    });\n  };\n\n  Range.prototype.equals = function equals (other) {\n    return other instanceof Range\n      ? this._start === other._start &&\n          this._end === other._end &&\n          this._step === other._step\n      : deepEqual(this, other);\n  };\n\n  return Range;\n}(IndexedSeq));\n\nvar EMPTY_RANGE;\n\n// Note: all of these methods are deprecated.\nCollection.isIterable = isCollection;\nCollection.isKeyed = isKeyed;\nCollection.isIndexed = isIndexed;\nCollection.isAssociative = isAssociative;\nCollection.isOrdered = isOrdered;\n\nCollection.Iterator = Iterator;\n\nmixin(Collection, {\n  // ### Conversion to other types\n\n  toArray: function toArray() {\n    assertNotInfinite(this.size);\n    var array = new Array(this.size || 0);\n    this.valueSeq().__iterate(function (v, i) {\n      array[i] = v;\n    });\n    return array;\n  },\n\n  toIndexedSeq: function toIndexedSeq() {\n    return new ToIndexedSequence(this);\n  },\n\n  toJS: function toJS$1() {\n    return this.toSeq().map(toJS).toJSON();\n  },\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, true);\n  },\n\n  toMap: function toMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return Map(this.toKeyedSeq());\n  },\n\n  toObject: function toObject() {\n    assertNotInfinite(this.size);\n    var object = {};\n    this.__iterate(function (v, k) {\n      object[k] = v;\n    });\n    return object;\n  },\n\n  toOrderedMap: function toOrderedMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedMap(this.toKeyedSeq());\n  },\n\n  toOrderedSet: function toOrderedSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSet: function toSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return Set(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSetSeq: function toSetSeq() {\n    return new ToSetSequence(this);\n  },\n\n  toSeq: function toSeq() {\n    return isIndexed(this)\n      ? this.toIndexedSeq()\n      : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();\n  },\n\n  toStack: function toStack() {\n    // Use Late Binding here to solve the circular dependency.\n    return Stack(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toList: function toList() {\n    // Use Late Binding here to solve the circular dependency.\n    return List(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  // ### Common JavaScript methods and properties\n\n  toString: function toString() {\n    return '[Collection]';\n  },\n\n  __toString: function __toString(head, tail) {\n    if (this.size === 0) {\n      return head + tail;\n    }\n    return head +\n      ' ' +\n      this.toSeq().map(this.__toStringMapper).join(', ') +\n      ' ' +\n      tail;\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  concat: function concat() {\n    var values = [], len = arguments.length;\n    while ( len-- ) values[ len ] = arguments[ len ];\n\n    return reify(this, concatFactory(this, values));\n  },\n\n  includes: function includes(searchValue) {\n    return this.some(function (value) { return is(value, searchValue); });\n  },\n\n  entries: function entries() {\n    return this.__iterator(ITERATE_ENTRIES);\n  },\n\n  every: function every(predicate, context) {\n    assertNotInfinite(this.size);\n    var returnValue = true;\n    this.__iterate(function (v, k, c) {\n      if (!predicate.call(context, v, k, c)) {\n        returnValue = false;\n        return false;\n      }\n    });\n    return returnValue;\n  },\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, true));\n  },\n\n  find: function find(predicate, context, notSetValue) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[1] : notSetValue;\n  },\n\n  forEach: function forEach(sideEffect, context) {\n    assertNotInfinite(this.size);\n    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n  },\n\n  join: function join(separator) {\n    assertNotInfinite(this.size);\n    separator = separator !== undefined ? '' + separator : ',';\n    var joined = '';\n    var isFirst = true;\n    this.__iterate(function (v) {\n      isFirst ? (isFirst = false) : (joined += separator);\n      joined += v !== null && v !== undefined ? v.toString() : '';\n    });\n    return joined;\n  },\n\n  keys: function keys() {\n    return this.__iterator(ITERATE_KEYS);\n  },\n\n  map: function map(mapper, context) {\n    return reify(this, mapFactory(this, mapper, context));\n  },\n\n  reduce: function reduce$1(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      false\n    );\n  },\n\n  reduceRight: function reduceRight(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      true\n    );\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, true));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, true));\n  },\n\n  some: function some(predicate, context) {\n    return !this.every(not(predicate), context);\n  },\n\n  sort: function sort(comparator) {\n    return reify(this, sortFactory(this, comparator));\n  },\n\n  values: function values() {\n    return this.__iterator(ITERATE_VALUES);\n  },\n\n  // ### More sequential methods\n\n  butLast: function butLast() {\n    return this.slice(0, -1);\n  },\n\n  isEmpty: function isEmpty() {\n    return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });\n  },\n\n  count: function count(predicate, context) {\n    return ensureSize(\n      predicate ? this.toSeq().filter(predicate, context) : this\n    );\n  },\n\n  countBy: function countBy(grouper, context) {\n    return countByFactory(this, grouper, context);\n  },\n\n  equals: function equals(other) {\n    return deepEqual(this, other);\n  },\n\n  entrySeq: function entrySeq() {\n    var collection = this;\n    if (collection._cache) {\n      // We cache as an entries array, so we can just return the cache!\n      return new ArraySeq(collection._cache);\n    }\n    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n    entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };\n\n    // Entries are plain Array, which do not define toJS, so it must\n    // manually converts keys and values before conversion.\n    entriesSequence.toJS = function() {\n      return this.map(function (entry) { return [toJS(entry[0]), toJS(entry[1])]; }).toJSON();\n    };\n\n    return entriesSequence;\n  },\n\n  filterNot: function filterNot(predicate, context) {\n    return this.filter(not(predicate), context);\n  },\n\n  findEntry: function findEntry(predicate, context, notSetValue) {\n    var found = notSetValue;\n    this.__iterate(function (v, k, c) {\n      if (predicate.call(context, v, k, c)) {\n        found = [k, v];\n        return false;\n      }\n    });\n    return found;\n  },\n\n  findKey: function findKey(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry && entry[0];\n  },\n\n  findLast: function findLast(predicate, context, notSetValue) {\n    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n  },\n\n  findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n    return this.toKeyedSeq()\n      .reverse()\n      .findEntry(predicate, context, notSetValue);\n  },\n\n  findLastKey: function findLastKey(predicate, context) {\n    return this.toKeyedSeq().reverse().findKey(predicate, context);\n  },\n\n  first: function first() {\n    return this.find(returnTrue);\n  },\n\n  flatMap: function flatMap(mapper, context) {\n    return reify(this, flatMapFactory(this, mapper, context));\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, true));\n  },\n\n  fromEntrySeq: function fromEntrySeq() {\n    return new FromEntriesSequence(this);\n  },\n\n  get: function get(searchKey, notSetValue) {\n    return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);\n  },\n\n  getIn: function getIn(searchKeyPath, notSetValue) {\n    var nested = this;\n    var keyPath = coerceKeyPath(searchKeyPath);\n    var i = 0;\n    while (i !== keyPath.length) {\n      if (!nested || !nested.get) {\n        throw new TypeError(\n          'Invalid keyPath: Value at [' +\n            keyPath.slice(0, i).map(quoteString) +\n            '] does not have a .get() method: ' +\n            nested\n        );\n      }\n      nested = nested.get(keyPath[i++], NOT_SET);\n      if (nested === NOT_SET) {\n        return notSetValue;\n      }\n    }\n    return nested;\n    // var step;\n    // while (!(step = iter.next()).done) {\n    //   var key = step.value;\n    //   nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n    //   if (nested === NOT_SET) {\n    //     return notSetValue;\n    //   }\n    // }\n    // return nested;\n  },\n\n  groupBy: function groupBy(grouper, context) {\n    return groupByFactory(this, grouper, context);\n  },\n\n  has: function has(searchKey) {\n    return this.get(searchKey, NOT_SET) !== NOT_SET;\n  },\n\n  hasIn: function hasIn(searchKeyPath) {\n    return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n  },\n\n  isSubset: function isSubset(iter) {\n    iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n    return this.every(function (value) { return iter.includes(value); });\n  },\n\n  isSuperset: function isSuperset(iter) {\n    iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n    return iter.isSubset(this);\n  },\n\n  keyOf: function keyOf(searchValue) {\n    return this.findKey(function (value) { return is(value, searchValue); });\n  },\n\n  keySeq: function keySeq() {\n    return this.toSeq().map(keyMapper).toIndexedSeq();\n  },\n\n  last: function last() {\n    return this.toSeq().reverse().first();\n  },\n\n  lastKeyOf: function lastKeyOf(searchValue) {\n    return this.toKeyedSeq().reverse().keyOf(searchValue);\n  },\n\n  max: function max(comparator) {\n    return maxFactory(this, comparator);\n  },\n\n  maxBy: function maxBy(mapper, comparator) {\n    return maxFactory(this, comparator, mapper);\n  },\n\n  min: function min(comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator\n    );\n  },\n\n  minBy: function minBy(mapper, comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator,\n      mapper\n    );\n  },\n\n  rest: function rest() {\n    return this.slice(1);\n  },\n\n  skip: function skip(amount) {\n    return amount === 0 ? this : this.slice(Math.max(0, amount));\n  },\n\n  skipLast: function skipLast(amount) {\n    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, true));\n  },\n\n  skipUntil: function skipUntil(predicate, context) {\n    return this.skipWhile(not(predicate), context);\n  },\n\n  sortBy: function sortBy(mapper, comparator) {\n    return reify(this, sortFactory(this, comparator, mapper));\n  },\n\n  take: function take(amount) {\n    return this.slice(0, Math.max(0, amount));\n  },\n\n  takeLast: function takeLast(amount) {\n    return this.slice(-Math.max(0, amount));\n  },\n\n  takeWhile: function takeWhile(predicate, context) {\n    return reify(this, takeWhileFactory(this, predicate, context));\n  },\n\n  takeUntil: function takeUntil(predicate, context) {\n    return this.takeWhile(not(predicate), context);\n  },\n\n  update: function update(fn) {\n    return fn(this);\n  },\n\n  valueSeq: function valueSeq() {\n    return this.toIndexedSeq();\n  },\n\n  // ### Hashable Object\n\n  hashCode: function hashCode() {\n    return this.__hash || (this.__hash = hashCollection(this));\n  }\n\n  // ### Internal\n\n  // abstract __iterate(fn, reverse)\n\n  // abstract __iterator(type, reverse)\n});\n\nvar CollectionPrototype = Collection.prototype;\nCollectionPrototype[IS_ITERABLE_SENTINEL] = true;\nCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\nCollectionPrototype.toJSON = CollectionPrototype.toArray;\nCollectionPrototype.__toStringMapper = quoteString;\nCollectionPrototype.inspect = (CollectionPrototype.toSource = function() {\n  return this.toString();\n});\nCollectionPrototype.chain = CollectionPrototype.flatMap;\nCollectionPrototype.contains = CollectionPrototype.includes;\n\nmixin(KeyedCollection, {\n  // ### More sequential methods\n\n  flip: function flip() {\n    return reify(this, flipFactory(this));\n  },\n\n  mapEntries: function mapEntries(mapper, context) {\n    var this$1 = this;\n\n    var iterations = 0;\n    return reify(\n      this,\n      this.toSeq()\n        .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })\n        .fromEntrySeq()\n    );\n  },\n\n  mapKeys: function mapKeys(mapper, context) {\n    var this$1 = this;\n\n    return reify(\n      this,\n      this.toSeq().flip().map(function (k, v) { return mapper.call(context, k, v, this$1); }).flip()\n    );\n  }\n});\n\nvar KeyedCollectionPrototype = KeyedCollection.prototype;\nKeyedCollectionPrototype[IS_KEYED_SENTINEL] = true;\nKeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\nKeyedCollectionPrototype.toJSON = CollectionPrototype.toObject;\nKeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };\n\nmixin(IndexedCollection, {\n  // ### Conversion to other types\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, false);\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, false));\n  },\n\n  findIndex: function findIndex(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  indexOf: function indexOf(searchValue) {\n    var key = this.keyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  lastIndexOf: function lastIndexOf(searchValue) {\n    var key = this.lastKeyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, false));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, false));\n  },\n\n  splice: function splice(index, removeNum /*, ...values*/) {\n    var numArgs = arguments.length;\n    removeNum = Math.max(removeNum || 0, 0);\n    if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n      return this;\n    }\n    // If index is negative, it should resolve relative to the size of the\n    // collection. However size may be expensive to compute if not cached, so\n    // only call count() if the number is in fact negative.\n    index = resolveBegin(index, index < 0 ? this.count() : this.size);\n    var spliced = this.slice(0, index);\n    return reify(\n      this,\n      numArgs === 1\n        ? spliced\n        : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n    );\n  },\n\n  // ### More collection methods\n\n  findLastIndex: function findLastIndex(predicate, context) {\n    var entry = this.findLastEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  first: function first() {\n    return this.get(0);\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, false));\n  },\n\n  get: function get(index, notSetValue) {\n    index = wrapIndex(this, index);\n    return index < 0 ||\n      (this.size === Infinity || (this.size !== undefined && index > this.size))\n      ? notSetValue\n      : this.find(function (_, key) { return key === index; }, undefined, notSetValue);\n  },\n\n  has: function has(index) {\n    index = wrapIndex(this, index);\n    return index >= 0 &&\n      (this.size !== undefined\n        ? this.size === Infinity || index < this.size\n        : this.indexOf(index) !== -1);\n  },\n\n  interpose: function interpose(separator) {\n    return reify(this, interposeFactory(this, separator));\n  },\n\n  interleave: function interleave(/*...collections*/) {\n    var collections = [this].concat(arrCopy(arguments));\n    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n    var interleaved = zipped.flatten(true);\n    if (zipped.size) {\n      interleaved.size = zipped.size * collections.length;\n    }\n    return reify(this, interleaved);\n  },\n\n  keySeq: function keySeq() {\n    return Range(0, this.size);\n  },\n\n  last: function last() {\n    return this.get(-1);\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, false));\n  },\n\n  zip: function zip(/*, ...collections */) {\n    var collections = [this].concat(arrCopy(arguments));\n    return reify(this, zipWithFactory(this, defaultZipper, collections));\n  },\n\n  zipWith: function zipWith(zipper /*, ...collections */) {\n    var collections = arrCopy(arguments);\n    collections[0] = this;\n    return reify(this, zipWithFactory(this, zipper, collections));\n  }\n});\n\nvar IndexedCollectionPrototype = IndexedCollection.prototype;\nIndexedCollectionPrototype[IS_INDEXED_SENTINEL] = true;\nIndexedCollectionPrototype[IS_ORDERED_SENTINEL] = true;\n\nmixin(SetCollection, {\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  get: function get(value, notSetValue) {\n    return this.has(value) ? value : notSetValue;\n  },\n\n  includes: function includes(value) {\n    return this.has(value);\n  },\n\n  // ### More sequential methods\n\n  keySeq: function keySeq() {\n    return this.valueSeq();\n  }\n});\n\nSetCollection.prototype.has = CollectionPrototype.includes;\nSetCollection.prototype.contains = SetCollection.prototype.includes;\n\n// Mixin subclasses\n\nmixin(KeyedSeq, KeyedCollection.prototype);\nmixin(IndexedSeq, IndexedCollection.prototype);\nmixin(SetSeq, SetCollection.prototype);\n\n// #pragma Helper functions\n\nfunction reduce(collection, reducer, reduction, context, useFirst, reverse) {\n  assertNotInfinite(collection.size);\n  collection.__iterate(\n    function (v, k, c) {\n      if (useFirst) {\n        useFirst = false;\n        reduction = v;\n      } else {\n        reduction = reducer.call(context, reduction, v, k, c);\n      }\n    },\n    reverse\n  );\n  return reduction;\n}\n\nfunction keyMapper(v, k) {\n  return k;\n}\n\nfunction entryMapper(v, k) {\n  return [k, v];\n}\n\nfunction toJS(value) {\n  return value && typeof value.toJS === 'function' ? value.toJS() : value;\n}\n\nfunction not(predicate) {\n  return function() {\n    return !predicate.apply(this, arguments);\n  };\n}\n\nfunction neg(predicate) {\n  return function() {\n    return -predicate.apply(this, arguments);\n  };\n}\n\nfunction defaultZipper() {\n  return arrCopy(arguments);\n}\n\nfunction defaultNegComparator(a, b) {\n  return a < b ? 1 : a > b ? -1 : 0;\n}\n\nfunction hashCollection(collection) {\n  if (collection.size === Infinity) {\n    return 0;\n  }\n  var ordered = isOrdered(collection);\n  var keyed = isKeyed(collection);\n  var h = ordered ? 1 : 0;\n  var size = collection.__iterate(\n    keyed\n      ? ordered\n          ? function (v, k) {\n              h = 31 * h + hashMerge(hash(v), hash(k)) | 0;\n            }\n          : function (v, k) {\n              h = h + hashMerge(hash(v), hash(k)) | 0;\n            }\n      : ordered\n          ? function (v) {\n              h = 31 * h + hash(v) | 0;\n            }\n          : function (v) {\n              h = h + hash(v) | 0;\n            }\n  );\n  return murmurHashOfSize(size, h);\n}\n\nfunction murmurHashOfSize(size, h) {\n  h = imul(h, 0xcc9e2d51);\n  h = imul(h << 15 | h >>> -15, 0x1b873593);\n  h = imul(h << 13 | h >>> -13, 5);\n  h = (h + 0xe6546b64 | 0) ^ size;\n  h = imul(h ^ h >>> 16, 0x85ebca6b);\n  h = imul(h ^ h >>> 13, 0xc2b2ae35);\n  h = smi(h ^ h >>> 16);\n  return h;\n}\n\nfunction hashMerge(a, b) {\n  return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int\n}\n\nvar OrderedSet = (function (Set$$1) {\n  function OrderedSet(value) {\n    return value === null || value === undefined\n      ? emptyOrderedSet()\n      : isOrderedSet(value)\n          ? value\n          : emptyOrderedSet().withMutations(function (set) {\n              var iter = SetCollection(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v) { return set.add(v); });\n            });\n  }\n\n  if ( Set$$1 ) OrderedSet.__proto__ = Set$$1;\n  OrderedSet.prototype = Object.create( Set$$1 && Set$$1.prototype );\n  OrderedSet.prototype.constructor = OrderedSet;\n\n  OrderedSet.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedSet.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  OrderedSet.prototype.toString = function toString () {\n    return this.__toString('OrderedSet {', '}');\n  };\n\n  return OrderedSet;\n}(Set));\n\nfunction isOrderedSet(maybeOrderedSet) {\n  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n}\n\nOrderedSet.isOrderedSet = isOrderedSet;\n\nvar OrderedSetPrototype = OrderedSet.prototype;\nOrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\nOrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\nOrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\n\nOrderedSetPrototype.__empty = emptyOrderedSet;\nOrderedSetPrototype.__make = makeOrderedSet;\n\nfunction makeOrderedSet(map, ownerID) {\n  var set = Object.create(OrderedSetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_ORDERED_SET;\nfunction emptyOrderedSet() {\n  return EMPTY_ORDERED_SET ||\n    (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n}\n\nvar Record = function Record(defaultValues, name) {\n  var hasInitialized;\n\n  var RecordType = function Record(values) {\n    var this$1 = this;\n\n    if (values instanceof RecordType) {\n      return values;\n    }\n    if (!(this instanceof RecordType)) {\n      return new RecordType(values);\n    }\n    if (!hasInitialized) {\n      hasInitialized = true;\n      var keys = Object.keys(defaultValues);\n      var indices = (RecordTypePrototype._indices = {});\n      RecordTypePrototype._name = name;\n      RecordTypePrototype._keys = keys;\n      RecordTypePrototype._defaultValues = defaultValues;\n      for (var i = 0; i < keys.length; i++) {\n        var propName = keys[i];\n        indices[propName] = i;\n        if (RecordTypePrototype[propName]) {\n          /* eslint-disable no-console */\n          typeof console === 'object' &&\n            console.warn &&\n            console.warn(\n              'Cannot define ' +\n                recordName(this$1) +\n                ' with property \"' +\n                propName +\n                '\" since that property name is part of the Record API.'\n            );\n          /* eslint-enable no-console */\n        } else {\n          setProp(RecordTypePrototype, propName);\n        }\n      }\n    }\n    this.__ownerID = undefined;\n    this._values = List().withMutations(function (l) {\n      l.setSize(this$1._keys.length);\n      KeyedCollection(values).forEach(function (v, k) {\n        l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);\n      });\n    });\n  };\n\n  var RecordTypePrototype = (RecordType.prototype = Object.create(\n    RecordPrototype\n  ));\n  RecordTypePrototype.constructor = RecordType;\n\n  return RecordType;\n};\n\nRecord.prototype.toString = function toString () {\n    var this$1 = this;\n\n  var str = recordName(this) + ' { ';\n  var keys = this._keys;\n  var k;\n  for (var i = 0, l = keys.length; i !== l; i++) {\n    k = keys[i];\n    str += (i ? ', ' : '') + k + ': ' + quoteString(this$1.get(k));\n  }\n  return str + ' }';\n};\n\nRecord.prototype.equals = function equals (other) {\n  return this === other ||\n    (this._keys === other._keys && recordSeq(this).equals(recordSeq(other)));\n};\n\nRecord.prototype.hashCode = function hashCode () {\n  return recordSeq(this).hashCode();\n};\n\n// @pragma Access\n\nRecord.prototype.has = function has (k) {\n  return this._indices.hasOwnProperty(k);\n};\n\nRecord.prototype.get = function get (k, notSetValue) {\n  if (!this.has(k)) {\n    return notSetValue;\n  }\n  var index = this._indices[k];\n  var value = this._values.get(index);\n  return value === undefined ? this._defaultValues[k] : value;\n};\n\n// @pragma Modification\n\nRecord.prototype.set = function set (k, v) {\n  if (this.has(k)) {\n    var newValues = this._values.set(\n      this._indices[k],\n      v === this._defaultValues[k] ? undefined : v\n    );\n    if (newValues !== this._values && !this.__ownerID) {\n      return makeRecord(this, newValues);\n    }\n  }\n  return this;\n};\n\nRecord.prototype.remove = function remove (k) {\n  return this.set(k);\n};\n\nRecord.prototype.clear = function clear () {\n  var newValues = this._values.clear().setSize(this._keys.length);\n  return this.__ownerID ? this : makeRecord(this, newValues);\n};\n\nRecord.prototype.wasAltered = function wasAltered () {\n  return this._values.wasAltered();\n};\n\nRecord.prototype.toSeq = function toSeq () {\n  return recordSeq(this);\n};\n\nRecord.prototype.toJS = function toJS () {\n  return recordSeq(this).toJS();\n};\n\nRecord.prototype.__iterator = function __iterator (type, reverse) {\n  return recordSeq(this).__iterator(type, reverse);\n};\n\nRecord.prototype.__iterate = function __iterate (fn, reverse) {\n  return recordSeq(this).__iterate(fn, reverse);\n};\n\nRecord.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n  if (ownerID === this.__ownerID) {\n    return this;\n  }\n  var newValues = this._values.__ensureOwner(ownerID);\n  if (!ownerID) {\n    this.__ownerID = ownerID;\n    this._values = newValues;\n    return this;\n  }\n  return makeRecord(this, newValues, ownerID);\n};\n\nRecord.isRecord = isRecord;\nRecord.getDescriptiveName = recordName;\nvar RecordPrototype = Record.prototype;\nRecordPrototype[IS_RECORD_SENTINEL] = true;\nRecordPrototype[DELETE] = RecordPrototype.remove;\nRecordPrototype.getIn = CollectionPrototype.getIn;\nRecordPrototype.hasIn = CollectionPrototype.hasIn;\nRecordPrototype.merge = MapPrototype.merge;\nRecordPrototype.mergeWith = MapPrototype.mergeWith;\nRecordPrototype.mergeIn = MapPrototype.mergeIn;\nRecordPrototype.mergeDeep = MapPrototype.mergeDeep;\nRecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\nRecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\nRecordPrototype.setIn = MapPrototype.setIn;\nRecordPrototype.update = MapPrototype.update;\nRecordPrototype.updateIn = MapPrototype.updateIn;\nRecordPrototype.withMutations = MapPrototype.withMutations;\nRecordPrototype.asMutable = MapPrototype.asMutable;\nRecordPrototype.asImmutable = MapPrototype.asImmutable;\nRecordPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\nRecordPrototype.toJSON = (RecordPrototype.toObject = CollectionPrototype.toObject);\nRecordPrototype.inspect = (RecordPrototype.toSource = CollectionPrototype.toSource);\n\nfunction makeRecord(likeRecord, values, ownerID) {\n  var record = Object.create(Object.getPrototypeOf(likeRecord));\n  record._values = values;\n  record.__ownerID = ownerID;\n  return record;\n}\n\nfunction recordName(record) {\n  return record._name || record.constructor.name || 'Record';\n}\n\nfunction recordSeq(record) {\n  return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));\n}\n\nfunction setProp(prototype, name) {\n  try {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  } catch (error) {\n    // Object.defineProperty failed. Probably IE8.\n  }\n}\n\n/**\n * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n * undefined, returns an infinite sequence of `value`.\n */\nvar Repeat = (function (IndexedSeq$$1) {\n  function Repeat(value, times) {\n    if (!(this instanceof Repeat)) {\n      return new Repeat(value, times);\n    }\n    this._value = value;\n    this.size = times === undefined ? Infinity : Math.max(0, times);\n    if (this.size === 0) {\n      if (EMPTY_REPEAT) {\n        return EMPTY_REPEAT;\n      }\n      EMPTY_REPEAT = this;\n    }\n  }\n\n  if ( IndexedSeq$$1 ) Repeat.__proto__ = IndexedSeq$$1;\n  Repeat.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  Repeat.prototype.constructor = Repeat;\n\n  Repeat.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Repeat []';\n    }\n    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n  };\n\n  Repeat.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._value : notSetValue;\n  };\n\n  Repeat.prototype.includes = function includes (searchValue) {\n    return is(this._value, searchValue);\n  };\n\n  Repeat.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    return wholeSlice(begin, end, size)\n      ? this\n      : new Repeat(\n          this._value,\n          resolveEnd(end, size) - resolveBegin(begin, size)\n        );\n  };\n\n  Repeat.prototype.reverse = function reverse () {\n    return this;\n  };\n\n  Repeat.prototype.indexOf = function indexOf (searchValue) {\n    if (is(this._value, searchValue)) {\n      return 0;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    if (is(this._value, searchValue)) {\n      return this.size;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var size = this.size;\n    var i = 0;\n    while (i !== size) {\n      if (fn(this$1._value, reverse ? size - ++i : i++, this$1) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  Repeat.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1 = this;\n\n    var size = this.size;\n    var i = 0;\n    return new Iterator(\n      function () { return i === size\n          ? iteratorDone()\n          : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }\n    );\n  };\n\n  Repeat.prototype.equals = function equals (other) {\n    return other instanceof Repeat\n      ? is(this._value, other._value)\n      : deepEqual(other);\n  };\n\n  return Repeat;\n}(IndexedSeq));\n\nvar EMPTY_REPEAT;\n\nvar Immutable = {\n  Collection: Collection,\n  // Note: Iterable is deprecated\n  Iterable: Collection,\n\n  Seq: Seq,\n  Map: Map,\n  OrderedMap: OrderedMap,\n  List: List,\n  Stack: Stack,\n  Set: Set,\n  OrderedSet: OrderedSet,\n\n  Record: Record,\n  Range: Range,\n  Repeat: Repeat,\n\n  is: is,\n  fromJS: fromJS,\n  hash: hash,\n\n  isImmutable: isImmutable,\n  isCollection: isCollection,\n  isKeyed: isKeyed,\n  isIndexed: isIndexed,\n  isAssociative: isAssociative,\n  isOrdered: isOrdered,\n  isValueObject: isValueObject\n};\n\n// Note: Iterable is deprecated\nvar Iterable = Collection;\n\nexports['default'] = Immutable;\nexports.Collection = Collection;\nexports.Iterable = Iterable;\nexports.Seq = Seq;\nexports.Map = Map;\nexports.OrderedMap = OrderedMap;\nexports.List = List;\nexports.Stack = Stack;\nexports.Set = Set;\nexports.OrderedSet = OrderedSet;\nexports.Record = Record;\nexports.Range = Range;\nexports.Repeat = Repeat;\nexports.is = is;\nexports.fromJS = fromJS;\nexports.hash = hash;\nexports.isImmutable = isImmutable;\nexports.isCollection = isCollection;\nexports.isKeyed = isKeyed;\nexports.isIndexed = isIndexed;\nexports.isAssociative = isAssociative;\nexports.isOrdered = isOrdered;\nexports.isValueObject = isValueObject;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/immutable/dist/immutable.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}